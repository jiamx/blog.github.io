<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Kafka的Controller Broker是什么 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kafka的Controller Broker是什么</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kafka的Controller Broker是什么</h1><div class="post-meta">Jul 6, 2020<span> | </span><span class="category"><a href="/categories/Kafka/">Kafka</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><a id="more"></a>

<p><strong>控制器组件（Controller），是 Apache Kafka 的核心组件。它的主要作用是在 Apache ZooKeeper 的帮助下管理和协调整个 Kafka 集群</strong>。集群中任意一台 Broker 都能充当控制器的角色，但是，在运行过程中，只能有一个 Broker 成为控制器，行使其管理和协调的职责。接下来，我们将讨论Controller原理和内部运行机制。通过本文你可以了解到：</p>
<ul>
<li>什么是Controller Broker</li>
<li>Controller Broker是怎么被选举的</li>
<li>Controller Broker主要作用是什么</li>
<li>Kafka是如何处理脑裂的</li>
</ul>
<h2 id="什么是Controller-Broker"><a href="#什么是Controller-Broker" class="headerlink" title="什么是Controller Broker"></a>什么是Controller Broker</h2><p>在分布式系统中，通常需要有一个协调者，该协调者会在分布式系统发生异常时发挥特殊的作用。在Kafka中该协调者称之为控制器(Controller),其实该控制器并没有什么特殊之处，它本身也是一个普通的Broker，只不过需要负责一些额外的工作(追踪集群中的其他Broker，并在合适的时候处理新加入的和失败的Broker节点、Rebalance分区、分配新的leader分区等)。值得注意的是：<strong>Kafka集群中始终只有一个Controller Broker。</strong></p>
<h2 id="Controller-Broker是如何被选出来的"><a href="#Controller-Broker是如何被选出来的" class="headerlink" title="Controller Broker是如何被选出来的"></a>Controller Broker是如何被选出来的</h2><p>上一小节解释了什么是Controller Broker，并且每台 Broker 都有充当控制器的可能性。那么，控制器是如何被选出来的呢？当集群启动后，Kafka 怎么确认控制器位于哪台 Broker 呢？</p>
<p>实际上，Broker 在启动时，会尝试去 ZooKeeper 中创建 /controller 节点。Kafka 当前选举控制器的规则是：<strong>第一个成功创建 /controller 节点的 Broker 会被指定为控制器</strong>。</p>
<h2 id="Controller-Broker的具体作用是什么"><a href="#Controller-Broker的具体作用是什么" class="headerlink" title="Controller Broker的具体作用是什么"></a>Controller Broker的具体作用是什么</h2><p>Controller Broker的主要职责有很多，主要是一些管理行为，主要包括以下几个方面：</p>
<ul>
<li>创建、删除主题，增加分区并分配leader分区</li>
<li>集群Broker管理（新增 Broker、Broker 主动关闭、Broker 故障)</li>
<li><strong>preferred leader</strong>选举</li>
<li>分区重分配</li>
</ul>
<h3 id="处理集群中下线的Broker"><a href="#处理集群中下线的Broker" class="headerlink" title="处理集群中下线的Broker"></a>处理集群中下线的Broker</h3><p>当某个Broker节点由于故障离开Kafka群集时，则存在于该Broker的leader分区将不可用(由于客户端仅对leader分区进行读写操作)。为了最大程度地减少停机时间，需要快速找到替代的leader分区。</p>
<p>Controller Broker可以对失败的Broker做出响应，Controller Broker可以从Zookeeper监听(zookeeper watch)中获取通知信息，ZooKeeper 赋予客户端监控 znode 变更的能力，即所谓的 Watch 通知功能。一旦 znode 节点被创建、删除，子节点数量发生变化，抑或是 znode 所存的数据本身变更，ZooKeeper 会通过节点变更监听器 (ChangeHandler) 的方式显式通知客户端。</p>
<p>每个 Broker 启动后，会在zookeeper的 /Brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行后续的协调操作。</p>
<p>Controller将收到通知并对此采取行动，决定哪些Broker上的分区成为leader分区，然后，它会通知每个相关的Broker，要么将Broker上的主题分区变成leader，要么通过<code>LeaderAndIsr</code>请求从新的leader分区中复制数据。</p>
<h3 id="处理新加入到集群中的Broker"><a href="#处理新加入到集群中的Broker" class="headerlink" title="处理新加入到集群中的Broker"></a>处理新加入到集群中的Broker</h3><p>通过将Leader分区副本均匀地分布在集群的不同Broker上，可以保障集群的负载均衡。在Broker发生故障时，某些Broker上的分区副本会被选举为leader，会造成一个Broker上存在多个leader分区副本的情况，由于客户端只与leader分区副本交互，所以这会给Broker增加额外的负担，并损害集群的性能和运行状况。因此，尽快恢复平衡对集群的健康运行是有益的。</p>
<p>Kafka认为leader分区副本最初的分配（每个节点都处于活跃状态）是均衡的。这些被最初选中的分区副本就是所谓的<strong>首选领导者(preferred leaders)</strong>。由于Kafka还支持<strong>机架感知的leader选举(rack-aware leader election</strong>) ,即尝试将leader分区和follower分区放置在不同的机架上，以增加对机架故障的容错能力。因此，leader分区副本的存在位置会对集群的可靠性产生影响。</p>
<p>默认情况下<strong>auto.leader.rebalance.enabled</strong>为true，表示允许 Kafka 定期地对一些 Topic 分区进行<br>Leader 重选举。大部分情况下，Broker的失败很短暂，这意味着Broker通常会在短时间内恢复。所以当节点离开群集时，与其相关联的元数据并不会被立即删除。</p>
<p>当Controller注意到Broker已加入集群时，它将使用Broker ID来检查该Broker上是否存在分区，如果存在，则Controller通知新加入的Broker和现有的Broker，新的Broker上面的follower分区再次开始复制现有leader分区的消息。为了保证负载均衡，Controller会将新加入的Broker上的follower分区选举为leader分区。</p>
<p><strong>注意</strong>：上面提到的选Leader分区，严格意义上是换Leader分区，为了达到负载均衡，可能会造成原来正常的Leader分区被强行变为follower分区。换一次 Leader 代价是很高的，原本向 Leader分区A(原Leader分区) 发送请求的所有客户端都要切换成向 B (新的Leader分区)发送请求，建议你在生产环境中把这个参数设置成 false。</p>
<h3 id="同步副本-in-sync-replica-ISR-列表"><a href="#同步副本-in-sync-replica-ISR-列表" class="headerlink" title="同步副本(in-sync replica ,ISR)列表"></a>同步副本(<strong>in-sync replica</strong> ,ISR)列表</h3><p>ISR中的副本都是与Leader进行同步的副本，所以不在该列表的follower会被认为与Leader是不同步的. 那么，ISR中存在是什么副本呢？首先可以明确的是：Leader副本总是存在于ISR中。 而follower副本是否在ISR中，取决于该follower副本是否与Leader副本保持了“同步”。</p>
<p>始终保证拥有足够数量的同步副本是非常重要的。要将follower提升为Leader，它必须存在于<strong>同步副本列表中</strong>。每个分区都有一个同步副本列表，该列表由Leader分区和Controller进行更新。</p>
<p>选择一个同步副本列表中的分区作为leader 分区的过程称为<strong>clean leader election</strong>。注意，这里要与在非同步副本中选一个分区作为leader分区的过程区分开，在非同步副本中选一个分区作为leader的过程称之为<strong>unclean leader election</strong>。由于ISR是动态调整的，所以会存在ISR列表为空的情况，通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程可以通过Broker 端参数 *<em>unclean.leader.election.enable *</em>控制是否允许 Unclean 领导者选举。开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean Leader 选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。分布式系统的CAP理论说的就是这种情况。</p>
<p>不幸的是，<strong>unclean leader election</strong>的选举过程仍可能会造成数据的不一致，因为同步副本并不是<strong>完全</strong>同步的。由于复制是<strong>异步</strong>完成的，因此无法保证follower可以获取最新消息。比如Leader分区的最后一条消息的offset是100，此时副本的offset可能不是100，这受到两个参数的影响：</p>
<ul>
<li><strong>replica.lag.time.max.ms</strong>：同步副本滞后与leader副本的时间</li>
<li><strong>zookeeper.session.timeout.ms</strong>：与zookeeper会话超时时间</li>
</ul>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>如果controller Broker 挂掉了，Kafka集群必须找到可以替代的controller，集群将不能正常运转。这里面存在一个问题，很难确定Broker是挂掉了，还是仅仅只是短暂性的故障。但是，集群为了正常运转，必须选出新的controller。如果之前被取代的controller又正常了，他并不知道自己已经被取代了，那么此时集群中会出现两台controller。</p>
<p>其实这种情况是很容易发生。比如，某个controller由于GC而被认为已经挂掉，并选择了一个新的controller。在GC的情况下，在最初的controller眼中，并没有改变任何东西，该Broker甚至不知道它已经暂停了。因此，它将继续充当当前controller，这是分布式系统中的常见情况，称为脑裂。</p>
<p><img src="//jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/example.jpg" alt></p>
<p>假如，处于活跃状态的controller进入了长时间的GC暂停。它的ZooKeeper会话过期了，之前注册的<code>/controller</code>节点被删除。集群中其他Broker会收到zookeeper的这一通知。</p>
<p><img src="//jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/%E8%84%91%E8%A3%821.png" alt></p>
<p>由于集群中必须存在一个controller Broker，所以现在每个Broker都试图尝试成为新的controller。假设Broker 2速度比较快，成为了最新的controller Broker。此时，每个Broker会收到Broker2成为新的controller的通知，由于Broker3正在进行”stop the world”的GC，可能不会收到Broker2成为最新的controller的通知。</p>
<p><img src="//jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/%E8%84%91%E8%A3%822.png" alt></p>
<p>等到Broker3的GC完成之后，仍会认为自己是集群的controller，在Broker3的眼中好像什么都没有发生一样。</p>
<p><img src="//jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/%E8%84%91%E8%A3%823.png" alt></p>
<p>现在，集群中出现了两个controller，它们可能一起发出具有冲突的命令，就会出现脑裂的现象。如果对这种情况不加以处理，可能会导致严重的不一致。所以需要一种方法来区分谁是集群当前最新的Controller。</p>
<p>Kafka是通过使用<strong>epoch number</strong>（纪元编号，也称为隔离令牌）来完成的。epoch number只是单调递增的数字，第一次选出Controller时，epoch number值为1，如果再次选出新的Controller，则epoch number将为2，依次单调递增。</p>
<p>每个新选出的controller通过Zookeeper 的条件递增操作获得一个全新的、数值更大的epoch number 。其他Broker 在知道当前epoch number 后，如果收到由controller发出的包含较旧(较小)epoch number的消息，就会忽略它们，即Broker根据最大的epoch number来区分当前最新的controller。</p>
<p><img src="//jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/%E8%84%91%E8%A3%824.png" alt></p>
<p>上图，Broker3向Broker1发出命令:让Broker1上的某个分区副本成为leader，该消息的epoch number值为1。于此同时，Broker2也向Broker1发送了相同的命令，不同的是，该消息的epoch number值为2，此时Broker1只听从Broker2的命令(由于其epoch number较大)，会忽略Broker3的命令，从而避免脑裂的发生。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲解了什么是Kafka Controller，它其实就是一个普通的Broker，除了需要负责一些额外的工作之外，其角色与其他的Broker基本一样。另外还介绍了Kafka Controller的主要职责，并对其中的一些职责进行了详细解释，最后还说明了kafka是如何避免脑裂的。</p>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/07/11/数仓-大数据时代-维度建模过时了吗/" target="_blank">数仓|大数据时代,维度建模过时了吗?</a></li><li><a href="https://jiamaoxiang.top/2020/07/09/使SQL更易于阅读的几个小技巧/" target="_blank">使SQL更易于阅读的几个小技巧</a></li><li><a href="https://jiamaoxiang.top/2020/07/05/Kafka生产者ack机制剖析/" target="_blank">Kafka生产者ack机制剖析</a></li><li><a href="https://jiamaoxiang.top/2020/06/30/数仓开发应避免的10个陷阱/" target="_blank">数仓开发应避免的10个陷阱</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/07/06/Kafka的Controller-Broker是什么/">https://jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/07/06/Kafka的Controller-Broker是什么/" data-id="cketb5ynk002qeg7q98f70jkg" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtklEQVR42u3aMW7EMAwEQP//00mTIkBgeUlKxiGYqwLfwdaoMJkVryv+fP35rK/ffXv3y/UTf1+5Tnzw8PDwxktfM9YPS6jVX/59YmHj8PDw8I7x7haa3DoHJKUlf9Z6zXh4eHifw4tuenM9h+Hh4eH9P15eHvK2Oyfh4eHhfQIvaW2rbXcvCK4GGduyFjw8PLz+2dPVY7z595HzPTw8PLzxqXrywq221NUC0Fvnzx3w8PDwDvDyF+6uLcib9WQ7opgDDw8Pbysvjw+SYpBHEsmRWP7t7T3x8PDwDvMm4wLnAt9q3FyeXMDDw8Mb8/ID/t5YVR5nJIXh4Sl4eHh4B3jVt2gvwJ0sq3r9ygF4eHh4LV6yxDwgmIPX7PLoFR4eHt4BXrLEyft2Hj1sKGx4eHh4W3k9xq5We1I8onXi4eHhHeatC0P++u7BeviHwoOHh4f3Om9ycDWJGKqwwkwZHh4e3iZeHgQkS0wKTHWDyuNWvZwDDw8PL+atr+eRRBXfu1uhNcfDw8M7wJufnuUNcfJyT7Y7CSPKSDw8PLwir7oTvRGB6qb0CszDAAEeHh7emJc8IF9ub6Qgr1flb/Hw8PAO8HYNP+WtcN6498Yabp+Ih4eHd4y36+C/2ijnjGr7joeHh3eC1xsIqEa31eY7P4p7WBseHh7e67x8sGB+fFVNEqLChoeHh3eMVwXvGodqntrFd8DDw8M7zUva37zVrt6tFwFHYQQeHh7eJt5X8ZNvUA82346HGAIPDw9vzKse6vfa3yS86P2m1+jj4eHhzXnV5nh+NNXbrLww4OHh4b3Dy0OKpJGdHKpNwgg8PDy8z+fN2/FqY51EFVHKi4eHh/cir9f4Vtv0BBxtOh4eHt4xXi8ayL9NUuRqwYhGu/Dw8PAO8Hr/8E8KRm/IoBdV4OHh4W3lfQMA7NpPvjEi9wAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Kafka/">Kafka</a></div><div class="post-nav"><a class="pre" href="/2020/07/09/使SQL更易于阅读的几个小技巧/">使SQL更易于阅读的几个小技巧</a><a class="next" href="/2020/07/05/Kafka生产者ack机制剖析/">Kafka生产者ack机制剖析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Controller-Broker"><span class="toc-number">1.</span> <span class="toc-text">什么是Controller Broker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-Broker是如何被选出来的"><span class="toc-number">2.</span> <span class="toc-text">Controller Broker是如何被选出来的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-Broker的具体作用是什么"><span class="toc-number">3.</span> <span class="toc-text">Controller Broker的具体作用是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#处理集群中下线的Broker"><span class="toc-number">3.1.</span> <span class="toc-text">处理集群中下线的Broker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理新加入到集群中的Broker"><span class="toc-number">3.2.</span> <span class="toc-text">处理新加入到集群中的Broker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步副本-in-sync-replica-ISR-列表"><span class="toc-number">3.3.</span> <span class="toc-text">同步副本(in-sync replica ,ISR)列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脑裂"><span class="toc-number">4.</span> <span class="toc-text">脑裂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>