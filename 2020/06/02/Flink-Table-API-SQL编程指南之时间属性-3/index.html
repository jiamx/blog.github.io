<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Flink Table API&amp;SQL编程指南之时间属性(3) | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink Table API&amp;SQL编程指南之时间属性(3)</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink Table API&amp;SQL编程指南之时间属性(3)</h1><div class="post-meta">Jun 2, 2020<span> | </span><span class="category"><a href="/categories/Flink/">Flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Flink总共有三种时间语义：<em>Processing time</em>(处理时间)、<em>Event time</em>(事件时间)以及<em>Ingestion time</em>(摄入时间)。关于这些时间语义的具体解释，可以参考另一篇文章<a href="https://mp.weixin.qq.com/s/ycz_N5m6RjsW9ZBhNMvACw" target="_blank" rel="noopener">Flink的时间与watermarks详解</a>。本文主要讲解Flink Table API &amp; SQL中基于时间的算子如何定义时间语义。通过本文你可以了解到：</p>
<ul>
<li>时间属性的简介</li>
<li>处理时间</li>
<li>事件时间</li>
</ul>
<h2 id="时间属性简介"><a href="#时间属性简介" class="headerlink" title="时间属性简介"></a>时间属性简介</h2><p>Flink TableAPI&amp;SQL中的基于时间的操作(如window)，需要指定时间语义，表可以根据指定的时间戳提供一个逻辑时间属性。</p>
<p>时间属性是表schama的一部分，当使用DDL创建表时、DataStream转为表时或者使用TableSource时，会定义时间属性。一旦时间属性被定义完成，该时间属性可以看做是一个字段的引用，从而在基于时间的操作中使用该字段。</p>
<p>时间属性像一个时间戳，可以被访问并参与计算，如果一个时间属性参与计算，那么该时间属性会被雾化成一个常规的时间戳，常规的时间戳不能与Flink的时间与水位线兼容，不能被基于时间的操作所使用。</p>
<p>Flink TableAPI &amp; SQL所需要的时间属性可以通过Datastream程序中指定，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime); <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以选择:</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span></span><br></pre></td></tr></table></figure>

<h2 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h2><p>基于本地的机器时间，是一种最简单的时间语义，但是不能保证结果一致性，使用该时间语义不需要提取时间戳和生成水位线。总共有三种方式定义处理时间属性，具体如下</p>
<h3 id="DDL语句创建表时定义处理时间"><a href="#DDL语句创建表时定义处理时间" class="headerlink" title="DDL语句创建表时定义处理时间"></a>DDL语句创建表时定义处理时间</h3><p>处理时间的属性可以在DDL语句中被定义为一个计算列，需要使用PROCTIME()函数，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_actions (</span><br><span class="line">  user_name <span class="keyword">STRING</span>,</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">STRING</span>,</span><br><span class="line">  user_action_time <span class="keyword">AS</span> PROCTIME() <span class="comment">-- 声明一个额外字段，作为处理时间属性</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TUMBLE_START(user_action_time, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTE</span>), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_name)</span><br><span class="line"><span class="keyword">FROM</span> user_actions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(user_action_time, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTE</span>); <span class="comment">-- 10分钟的滚动窗口</span></span><br></pre></td></tr></table></figure>

<h3 id="DataStream转为Table的过程中定义处理时间"><a href="#DataStream转为Table的过程中定义处理时间" class="headerlink" title="DataStream转为Table的过程中定义处理时间"></a>DataStream转为Table的过程中定义处理时间</h3><p>在将DataStream转为表时，在schema定义中可以通过.proctime属性指定时间属性，并将其放在其他schema字段的最后面，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = ...;</span><br><span class="line"><span class="comment">// 声明一个额外逻辑字段作为处理时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, <span class="string">"user_name, data, user_action_time.proctime"</span>);</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = table.window(Tumble.over(<span class="string">"10.minutes"</span>).on(<span class="string">"user_action_time"</span>).as(<span class="string">"userActionWindow"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="使用TableSource"><a href="#使用TableSource" class="headerlink" title="使用TableSource"></a>使用TableSource</h3><p>自定义TableSource并实现<code>DefinedProctimeAttribute</code> 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义个带有处理时间属性的table source</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionSource</span> <span class="keyword">implements</span> <span class="title">StreamTableSource</span>&lt;<span class="title">Row</span>&gt;, <span class="title">DefinedProctimeAttribute</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String[] names = <span class="keyword">new</span> String[] &#123;<span class="string">"user_name"</span> , <span class="string">"data"</span>&#125;;</span><br><span class="line">		TypeInformation[] types = <span class="keyword">new</span> TypeInformation[] &#123;Types.STRING(), Types.STRING()&#125;;</span><br><span class="line">		<span class="keyword">return</span> Types.ROW(names, types);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataStream&lt;Row&gt; <span class="title">getDataStream</span><span class="params">(StreamExecutionEnvironment execEnv)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建stream</span></span><br><span class="line">		DataStream&lt;Row&gt; stream = ...;</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getProctimeAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该字段会追加到schema中，作为第三个字段</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"user_action_time"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册table source</span></span><br><span class="line">tEnv.registerTableSource(<span class="string">"user_actions"</span>, <span class="keyword">new</span> UserActionSource());</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = tEnv</span><br><span class="line">	.from(<span class="string">"user_actions"</span>)</span><br><span class="line">	.window(Tumble.over(<span class="string">"10.minutes"</span>).on(<span class="string">"user_action_time"</span>).as(<span class="string">"userActionWindow"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h2><p>基于记录的具体时间戳，即便是存在乱序或者迟到数据也会保证结果的一致性。总共有三种方式定义处理时间属性，具体如下</p>
<h3 id="DDL语句创建表时定事件时间"><a href="#DDL语句创建表时定事件时间" class="headerlink" title="DDL语句创建表时定事件时间"></a>DDL语句创建表时定事件时间</h3><p>事件时间属性可以通过 WATERMARK语句进行定义，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_actions (</span><br><span class="line">  user_name <span class="keyword">STRING</span>,</span><br><span class="line">  <span class="keyword">data</span> <span class="keyword">STRING</span>,</span><br><span class="line">  user_action_time <span class="built_in">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  <span class="comment">-- 声明user_action_time作为事件时间属性，并允许5S的延迟  </span></span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> user_action_time <span class="keyword">AS</span> user_action_time - <span class="built_in">INTERVAL</span> <span class="string">'5'</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TUMBLE_START(user_action_time, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTE</span>), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> user_name)</span><br><span class="line"><span class="keyword">FROM</span> user_actions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(user_action_time, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTE</span>);</span><br></pre></td></tr></table></figure>

<h3 id="DataStream转为Table的过程中定义事件时间"><a href="#DataStream转为Table的过程中定义事件时间" class="headerlink" title="DataStream转为Table的过程中定义事件时间"></a>DataStream转为Table的过程中定义事件时间</h3><p>当定义Schema时通过.rowtime属性指定事件时间属性，必须在DataStream中指定时间戳与水位线。例如在数据集中，事件时间属性为event_time，此时Table中的事件时间字段中可以通过’event_time. rowtime‘来指定。</p>
<p>目前Flink支持两种方式定义EventTime字段，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1:</span></span><br><span class="line"><span class="comment">// 提取timestamp并分配watermarks</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个额外逻辑字段作为事件时间属性</span></span><br><span class="line"><span class="comment">// 在table schema的末尾使用user_action_time.rowtime定义事件时间属性</span></span><br><span class="line"><span class="comment">// 系统会在TableEnvironment中获取事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, <span class="string">"user_name, data, user_action_time.rowtime"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个字段提取timestamp并分配watermarks</span></span><br><span class="line">DataStream&lt;Tuple3&lt;Long, String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字段已经用来提取时间戳，可以直接使用对应的字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, <span class="string">"user_action_time.rowtime, user_name, data"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = table.window(Tumble.over(<span class="string">"10.minutes"</span>).on(<span class="string">"user_action_time"</span>).as(<span class="string">"userActionWindow"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="使用TableSource-1"><a href="#使用TableSource-1" class="headerlink" title="使用TableSource"></a>使用TableSource</h3><p>另外也可以在创建TableSource的时候，实现DefinedRowtimeAttributes接口来定义EventTime字段，在接口中需要实现getRowtimeAttributeDescriptors方法，创建基于EventTime的时间属性信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义带有rowtime属性的table source</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionSource</span> <span class="keyword">implements</span> <span class="title">StreamTableSource</span>&lt;<span class="title">Row</span>&gt;, <span class="title">DefinedRowtimeAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String[] names = <span class="keyword">new</span> String[] &#123;<span class="string">"user_name"</span>, <span class="string">"data"</span>, <span class="string">"user_action_time"</span>&#125;;</span><br><span class="line">		TypeInformation[] types =</span><br><span class="line">		    <span class="keyword">new</span> TypeInformation[] &#123;Types.STRING(), Types.STRING(), Types.LONG()&#125;;</span><br><span class="line">		<span class="keyword">return</span> Types.ROW(names, types);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataStream&lt;Row&gt; <span class="title">getDataStream</span><span class="params">(StreamExecutionEnvironment execEnv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流，基于user_action_time属性分配水位线</span></span><br><span class="line">		DataStream&lt;Row&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;RowtimeAttributeDescriptor&gt; <span class="title">getRowtimeAttributeDescriptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记user_action_time字段作为事件时间属性</span></span><br><span class="line">        <span class="comment">// 创建user_action_time描述符，用来标识时间属性字段</span></span><br><span class="line">		RowtimeAttributeDescriptor rowtimeAttrDescr = <span class="keyword">new</span> RowtimeAttributeDescriptor(</span><br><span class="line">			<span class="string">"user_action_time"</span>,</span><br><span class="line">			<span class="keyword">new</span> ExistingField(<span class="string">"user_action_time"</span>),</span><br><span class="line">			<span class="keyword">new</span> AscendingTimestamps());</span><br><span class="line">		List&lt;RowtimeAttributeDescriptor&gt; listRowtimeAttrDescr = Collections.singletonList(rowtimeAttrDescr);</span><br><span class="line">		<span class="keyword">return</span> listRowtimeAttrDescr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register表</span></span><br><span class="line">tEnv.registerTableSource(<span class="string">"user_actions"</span>, <span class="keyword">new</span> UserActionSource());</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = tEnv</span><br><span class="line">	.from(<span class="string">"user_actions"</span>)</span><br><span class="line">	.window(Tumble.over(<span class="string">"10.minutes"</span>).on(<span class="string">"user_action_time"</span>).as(<span class="string">"userActionWindow"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了如何在Flink Table API和SQL中使用时间语义，可以使用两种时间语义：处理时间和事件时间。分别对每种的时间语义的使用方式进行了详细解释。</p>
<blockquote>
<p>公众号『大数据技术与数仓』，回复『资料』领取大数据资料包</p>
</blockquote>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/06/06/数仓-Hive性能调优指北/" target="_blank">数仓|Hive性能调优指北</a></li><li><a href="https://jiamaoxiang.top/2020/06/05/实时数仓-Flink-SQL之维表join/" target="_blank">实时数仓|Flink SQL之维表join</a></li><li><a href="https://jiamaoxiang.top/2020/05/28/数仓开发需要了解的BI数据分析方法/" target="_blank">数仓开发需要了解的BI数据分析方法</a></li><li><a href="https://jiamaoxiang.top/2020/05/28/Flink-Table-API-SQL编程指南-2/" target="_blank">Flink Table API &amp; SQL编程指南之动态表(2)</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/06/02/Flink-Table-API-SQL编程指南之时间属性-3/">https://jiamaoxiang.top/2020/06/02/Flink-Table-API-SQL编程指南之时间属性-3/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/06/02/Flink-Table-API-SQL编程指南之时间属性-3/" data-id="ckiye93h3000qbo7qc40um9ky" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuElEQVR42u3aQZIiMQwEwPn/p3evu0EAVZINc8g+EYTpVvrQFpJ+fuLrzz/X4/fPPj9ejyuTJz57+rELDw8PbxH664DabzZb9npTkpjx8PDwbvOePT5f04bYHiHDePDw8PB+Aa9Njl/fM0ma86QcDw8P7/fzZqWHJPnODwk8PDy8b/E2ISYrkxLGrBRyrNaCh4eHF/NmqfB3P1/p7+Hh4eGtu+r5azpJlJOX+Kzd9fTOeHh4eBd4sxGo13/+Z8lxm+IXceLh4eEd5eVjT7Omflt4bUlvNh0PDw/vGi8pQMzS4lk5o03u684eHh4e3oKXBJQnsnmzqv1tXgSpJyPw8PDwSl4eRDsaldx50/KP1uPh4eFd4O1T3tkjZ4WGA5NleHh4eId4mzJBW9rYbFZbOsHDw8O7wWv//CeN/32W2yKjmTI8PDy8Q7xTobTNqrZEOzvM8PDw8D7Da1v1+7JFvmYWJx4eHt5neO2f/3a8IE/QE0aRRuPh4eGtefkj28fk+7r51ZumGh4eHt6XeHv2vmDRFin+q1Lj4eHhHeUlBYLkRu3B0N7zcHqNh4eHt+Dlj89LsfvQ66mxfOgKDw8P7xAvT3/3R0Jexm0Lynh4eHif4eUv3/bB+fq8APH6mCmGrvDw8PAO8dpA86OlTeLbokaUmuPh4eEd5SWL2nDzNfvtexMDHh4e3jVeXnLdFFhnba3VqBYeHh7eNV7ejspf8flAVT5eUG8xHh4e3lHejcGpfaK82Y6nQ1d4eHh4h3jta7dNf5MEegYuenp4eHh4F3iz0DffzwrHbTMMDw8P7zZvkxbnxd98K/PT7PAcGR4eHt413qYQnBcp8lJIMTqAh4eH9yVe/vrOf9uCh0NXeHh4eId4szT3bIqchNsWKfDw8PBu8No//LMibxLWZshg1eXDw8PDS3l/AUpvc6jfLiAPAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2020/06/05/实时数仓-Flink-SQL之维表join/">实时数仓|Flink SQL之维表join</a><a class="next" href="/2020/05/28/数仓开发需要了解的BI数据分析方法/">数仓开发需要了解的BI数据分析方法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#时间属性简介"><span class="toc-number">1.</span> <span class="toc-text">时间属性简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理时间"><span class="toc-number">2.</span> <span class="toc-text">处理时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL语句创建表时定义处理时间"><span class="toc-number">2.1.</span> <span class="toc-text">DDL语句创建表时定义处理时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataStream转为Table的过程中定义处理时间"><span class="toc-number">2.2.</span> <span class="toc-text">DataStream转为Table的过程中定义处理时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用TableSource"><span class="toc-number">2.3.</span> <span class="toc-text">使用TableSource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件时间"><span class="toc-number">3.</span> <span class="toc-text">事件时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL语句创建表时定事件时间"><span class="toc-number">3.1.</span> <span class="toc-text">DDL语句创建表时定事件时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataStream转为Table的过程中定义事件时间"><span class="toc-number">3.2.</span> <span class="toc-text">DataStream转为Table的过程中定义事件时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用TableSource-1"><span class="toc-number">3.3.</span> <span class="toc-text">使用TableSource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>