<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建</h1><div class="post-meta">Dec 11, 2020<span> | </span><span class="category"><a href="/categories/Spark/">Spark</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>互联网的飞速发展使得现代社会处于一个信息爆炸的时代，面对海量的数据与信息，如何筛选和过滤成为了一个具有挑战性的问题。近年来，推荐系统被证明是一种解决信息过载问题的有效工具，从根本上讲，推荐系统是通过为用户指引该用户不熟悉的新物品来解决信息过载现象的。了解用户对物品的偏好并精准预测用户喜欢的物品是构建推荐系统中比较困难的部分，协同过滤是解决上述问题的一种方法。</p>
<p>本文会基于Spark构建一个简单的推荐系统，使用的是基于物品的协同过滤算法。值得注意的是，本文不会去详细介绍各种推荐算法的基本原理和数学推导，也不会去用SparkML提供的<strong>交替最小二乘的隐语义模型推荐算法</strong>库进行实现，更不会涉及算法的相关改进，比如数据稀疏性、冷启动等等。本文旨在构建一个简易的电影推荐系统，依此来说明经典的推荐系统基本原理。除此之外，你还可以通过本文熟悉SparkRDD的基本操作。希望本文对你所有帮助，记得分享、点赞、在看。以下是全文。</p>
<h2 id="基于物品的协同过滤算法原理"><a href="#基于物品的协同过滤算法原理" class="headerlink" title="基于物品的协同过滤算法原理"></a>基于物品的协同过滤算法原理</h2><p>基于物品的协同过滤算法主要有两个步骤：</p>
<ul>
<li>计算物品之间的相似度</li>
<li>根据物品的相似度和用户的历史行为给用户生成推荐列表</li>
</ul>
<p>其中计算物品之间的相似度可以使用欧几里得距离，皮尔逊系数、Jaccard公式、余弦相似度等等。本文使用的是余弦相似度。关于具体的公式，可以自行搜索。下图是基于物品的推荐算法与基于用户的推荐算法示意图：</p>
<p><img src="//jiamaoxiang.top/2020/12/11/秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建/%E6%8E%A8%E8%8D%90.png" alt></p>
<p>即给定的评分矩阵，横向计算(某用户对所有有物品的评分向量)可以得到用户与用户之间的相似度，纵向计算(所有用户对该物品的评分向量)可以得出物品之间的相似度。</p>
<h2 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h2><p>选择的数据集为MovieLens的电影评分数据，主要包括两个文件：<strong>u.data</strong>和<strong>u.item</strong>，其中<strong>u.data</strong>是用户的评分数据，数据格式为[userId    movieId    rating    timestamp]，<strong>u.item</strong>为电影的基本信息，包括电影id，电影名称，上映时间，数据格式为：[movieId|mobieName|time|…]。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有步骤均已在代码中进行了详细解释，在此不再赘述，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MovieRecommendations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> spark = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="string">"local[*]"</span>, <span class="string">"Movie recommendations"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取用户评分表，对数据进行格式转换</span></span><br><span class="line"><span class="comment">    * 原始数据格式为:[userId,movieId,rating,timestamp]</span></span><br><span class="line"><span class="comment">    * 转换后的数据格式为:[(userId,(movieId,rating))]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mapUserIdAndMovieRatings</span></span>(): <span class="type">RDD</span>[(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">Double</span>))] = &#123;</span><br><span class="line">    <span class="keyword">val</span> dataFile: <span class="type">RDD</span>[<span class="type">String</span>] = spark.textFile(<span class="string">"E:/u.data"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userIdMappedWithMovieIdAndRating: <span class="type">RDD</span>[(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">Double</span>))] = dataFile.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> fields = line.split(<span class="string">"\\s+"</span>) <span class="comment">//按照空白字符进行切割</span></span><br><span class="line">      (fields(<span class="number">0</span>).toInt, (fields(<span class="number">1</span>).toInt, fields(<span class="number">2</span>).toDouble))</span><br><span class="line">    &#125;)</span><br><span class="line">    userIdMappedWithMovieIdAndRating</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对(userId,(movieId,rating))这种格式的数据进行自连接时，</span></span><br><span class="line"><span class="comment">    * 会得到某一个用户的所有评分数据，比如：用户1分别对电影1,2进行了评分，</span></span><br><span class="line"><span class="comment">    * (1,(1,2))          (1,(1,2))</span></span><br><span class="line"><span class="comment">    * (1,(2,4))   JOIN   (1,(2,4))</span></span><br><span class="line"><span class="comment">    * 则JOIN之后的数据为：</span></span><br><span class="line"><span class="comment">    * (1,((1,2),(1,2)))</span></span><br><span class="line"><span class="comment">    * (1,((1,2),(2,4)))</span></span><br><span class="line"><span class="comment">    * (1,((2,4),(1,2)))</span></span><br><span class="line"><span class="comment">    * (1,((2,4),(2,4)))</span></span><br><span class="line"><span class="comment">    * JOIN之后的数据会存在重复，</span></span><br><span class="line"><span class="comment">    * 去重之后的结果为：(1,((1,2),(2,4)))</span></span><br><span class="line"><span class="comment">    * 这样就得到了形如：userId-&gt; ((movieId,rating),(movieId,rating))的数据</span></span><br><span class="line"><span class="comment">    * 该数据格式表示某一用户对电影评分的两两组合</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param userIdAndPairOfMovies</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filterDuplicateMovieData</span></span>(userIdAndPairOfMovies: (<span class="type">Int</span>, ((<span class="type">Int</span>, <span class="type">Double</span>), (<span class="type">Int</span>, <span class="type">Double</span>)))): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> movieId1: <span class="type">Int</span> = userIdAndPairOfMovies._2._1._1</span><br><span class="line">    <span class="keyword">val</span> movieId2: <span class="type">Int</span> = userIdAndPairOfMovies._2._2._1</span><br><span class="line">    movieId1 &lt; movieId2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当我们拿到形如userId-&gt; ((movieId,rating),(movieId,rating))的数据时，</span></span><br><span class="line"><span class="comment">    * 接下来需要计算电影之间的余弦相似度，所以需要将数据加工为形如：</span></span><br><span class="line"><span class="comment">    * (MovieID1,MovieId2) -&gt; (Rating1,Rating2)的格式</span></span><br><span class="line"><span class="comment">    * 这样，就得到了两两电影组合及其对应的评分数据</span></span><br><span class="line"><span class="comment">    * 也就拿到了一个评分矩阵，即所有用户对某一部电影的评分，构成了该电影的一个向量</span></span><br><span class="line"><span class="comment">    * ----------------------------------------</span></span><br><span class="line"><span class="comment">    * userId |  movie1 | movie2| ... | movie3</span></span><br><span class="line"><span class="comment">    * ----------------------------------------</span></span><br><span class="line"><span class="comment">    * user1  |    2    |       | ... |   5</span></span><br><span class="line"><span class="comment">    * ----------------------------------------</span></span><br><span class="line"><span class="comment">    * user2  |    3    |   5   | ... |</span></span><br><span class="line"><span class="comment">    * ----------------------------------------</span></span><br><span class="line"><span class="comment">    * user3  |    4    |   2   | ... |   3</span></span><br><span class="line"><span class="comment">    * ----------------------------------------</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param userIdAndMovieData</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mapMoviePairsWithRatings</span></span>(userIdAndMovieData: (<span class="type">Int</span>, ((<span class="type">Int</span>, <span class="type">Double</span>), (<span class="type">Int</span>, <span class="type">Double</span>)))): ((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Double</span>)) = &#123;</span><br><span class="line">    <span class="keyword">val</span> movieId1 = userIdAndMovieData._2._1._1</span><br><span class="line">    <span class="keyword">val</span> movieId2 = userIdAndMovieData._2._2._1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rating1 = userIdAndMovieData._2._1._2</span><br><span class="line">    <span class="keyword">val</span> rating2 = userIdAndMovieData._2._2._2</span><br><span class="line"></span><br><span class="line">    ((movieId1, movieId2), (rating1, rating2))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算电影之间的余弦相似度</span></span><br><span class="line"><span class="comment">    * 当我们得到了形如(MovieID1,MovieId2) -&gt; (Rating1,Rating2)格式的数据</span></span><br><span class="line"><span class="comment">    * 再按照(MovieID1,MovieId2)进行分组，这样，相同组合的电影的评分就会分到一个组中，</span></span><br><span class="line"><span class="comment">    * 从而就得到了每个电影的评分对应的列向量</span></span><br><span class="line"><span class="comment">    * 比如对于[movie1,movie2]，所有用户对该组合的评分为：</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * --------------------------</span></span><br><span class="line"><span class="comment">    * userId |  movie1 | movie2</span></span><br><span class="line"><span class="comment">    * --------------------------</span></span><br><span class="line"><span class="comment">    * user1  |    2    |    3</span></span><br><span class="line"><span class="comment">    * --------------------------</span></span><br><span class="line"><span class="comment">    * user2  |    3    |    5</span></span><br><span class="line"><span class="comment">    * --------------------------</span></span><br><span class="line"><span class="comment">    * user3  |    4    |    2</span></span><br><span class="line"><span class="comment">    * --------------------------</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 即movie1对应的评分向量为：(2,3,4)</span></span><br><span class="line"><span class="comment">    * movie2对应的评分向量为：(3,5,2)</span></span><br><span class="line"><span class="comment">    * 则这两部电影的余弦相似度为：</span></span><br><span class="line"><span class="comment">    * (2*3 + 3*5 + 4*2)/ Math.sqrt(2² + 3² + 4²) * Math.sqrt(3² + 5² + 2²)</span></span><br><span class="line"><span class="comment">    * 返回的形式为[余弦相似度,评分个数]</span></span><br><span class="line"><span class="comment">    * @param ratingPairs</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">computeCosineSimilarity</span></span>(ratingPairs: <span class="type">Iterable</span>[(<span class="type">Double</span>, <span class="type">Double</span>)]): (<span class="type">Double</span>, <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">var</span> numOfPairs: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sumXX: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> sumYY: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> sumXY: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ratingPair: (<span class="type">Double</span>, <span class="type">Double</span>) &lt;- ratingPairs) &#123;</span><br><span class="line">      <span class="keyword">val</span> ratingX: <span class="type">Double</span> = ratingPair._1</span><br><span class="line">      <span class="keyword">val</span> ratingY: <span class="type">Double</span> = ratingPair._2</span><br><span class="line"></span><br><span class="line">      sumXX += ratingX * ratingX</span><br><span class="line">      sumYY += ratingY * ratingY</span><br><span class="line">      sumXY += ratingX * ratingY</span><br><span class="line">      numOfPairs += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> numerator: <span class="type">Double</span> = sumXY</span><br><span class="line">    <span class="keyword">val</span> denominator: <span class="type">Double</span> = <span class="type">Math</span>.sqrt(sumXX) * <span class="type">Math</span>.sqrt(sumYY)</span><br><span class="line">    <span class="keyword">val</span> result: <span class="type">Double</span> = numerator / denominator</span><br><span class="line">    (result, numOfPairs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取电影信息表，匹配电影id对应的电影名称</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mapMovieIdAndName</span></span>(): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> codec = <span class="type">Codec</span>(<span class="string">"UTF-8"</span>)</span><br><span class="line">    codec.onMalformedInput(<span class="type">CodingErrorAction</span>.<span class="type">REPLACE</span>)</span><br><span class="line">    codec.onUnmappableCharacter(<span class="type">CodingErrorAction</span>.<span class="type">REPLACE</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> idAndNameMapped: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = <span class="type">Source</span>.fromFile(<span class="string">"E:/u.item"</span>).getLines().map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> lineArr = line.split('|')</span><br><span class="line">      (lineArr.head.toInt, lineArr(<span class="number">1</span>)) <span class="comment">// 电影id和电影名称之间的映射</span></span><br><span class="line">    &#125;).toMap[<span class="type">Int</span>, <span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    idAndNameMapped</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印电影推荐列表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param moviesAndSimilarityScore 任意两部电影组合的余弦相似度</span></span><br><span class="line"><span class="comment">    * @param args                     传入参数，电影id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">suggestTop10Movies</span></span>(moviesAndSimilarityScore: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Int</span>))], args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"为您推荐以下电影列表: "</span>)</span><br><span class="line">    <span class="comment">// 余弦相似度的阈值,此处设为0.95</span></span><br><span class="line">    <span class="keyword">val</span> scoreThreshold: <span class="type">Double</span> = <span class="number">0.95</span></span><br><span class="line">    <span class="comment">// 至少要有大于等于100个的用户对该电影组合进行了评分</span></span><br><span class="line">    <span class="keyword">val</span> coOccurenceThreshold: <span class="type">Double</span> = <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取传入的电影id</span></span><br><span class="line">    <span class="keyword">val</span> movieId: <span class="type">Int</span> = args.head.toInt</span><br><span class="line">    <span class="comment">// 找到与传入参数的电影比较相似的电影，并排除该电影本身</span></span><br><span class="line">    <span class="keyword">val</span> moviePairsFilteredAccordingToThreshold: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Int</span>))] = moviesAndSimilarityScore.filter((moviePairAndScore: ((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Int</span>))) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> moviePair: (<span class="type">Int</span>, <span class="type">Int</span>) = moviePairAndScore._1</span><br><span class="line">      <span class="keyword">val</span> ratingAndNumOfPairs: (<span class="type">Double</span>, <span class="type">Int</span>) = moviePairAndScore._2</span><br><span class="line">      <span class="comment">// 该movieId属于该电影组合，并且余弦相似度大于0.98，超过100个用户对该电影组合进行了评分</span></span><br><span class="line">      (moviePair._1 == movieId || moviePair._2 == movieId) &amp;&amp; ratingAndNumOfPairs._1 &gt; scoreThreshold &amp;&amp; ratingAndNumOfPairs._2 &gt; coOccurenceThreshold</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 取出前10部推荐的电影</span></span><br><span class="line">    <span class="comment">// 即找到与该电影与相似度最为接近的电影</span></span><br><span class="line">    <span class="keyword">val</span> first10MoviesAndTheirScores: <span class="type">Array</span>[((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Int</span>))] = moviePairsFilteredAccordingToThreshold.take(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> idAndMovieNames = mapMovieIdAndName()</span><br><span class="line">    <span class="comment">// 根据key 获取value值</span></span><br><span class="line">    println(<span class="string">"与 "</span> + idAndMovieNames(movieId) + <span class="string">" 比较相近的电影为:"</span>)</span><br><span class="line">    first10MoviesAndTheirScores.foreach(moviePairAndScore =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> movie1: <span class="type">Int</span> = moviePairAndScore._1._1</span><br><span class="line">      <span class="keyword">val</span> movie2: <span class="type">Int</span> = moviePairAndScore._1._2</span><br><span class="line">      <span class="keyword">var</span> suggestedMovie: <span class="type">Int</span> = movie2</span><br><span class="line">      <span class="keyword">if</span> (movie2 == movieId) &#123;</span><br><span class="line">        suggestedMovie = movie1</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      println(idAndMovieNames(suggestedMovie))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置日志级别</span></span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">"org"</span>).setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用mapUserIdAndMovieRatings</span></span><br><span class="line">    <span class="comment">// 原始数据格式为:[userId,movieId,rating,timestamp]</span></span><br><span class="line">    <span class="comment">// 转换后的数据格式为:[(userId,(movieId,rating))]</span></span><br><span class="line">    <span class="keyword">val</span> userIdMappedWithMovieIdAndRatings: <span class="type">RDD</span>[(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">Double</span>))] = mapUserIdAndMovieRatings()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察</span></span><br><span class="line"><span class="comment">      * (196,(242,3.0))</span></span><br><span class="line"><span class="comment">      * (186,(302,3.0))</span></span><br><span class="line"><span class="comment">      * (22,(377,1.0))</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    userIdMappedWithMovieIdAndRatings.take(<span class="number">3</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于某一个用户，找到该用户对应的电影评分，并进行两两组合</span></span><br><span class="line">    <span class="comment">// 输出的格式为：[(userId, ((movie1, rating1), (movie2, rating2)))]</span></span><br><span class="line">    <span class="keyword">val</span> pairOfMoviesWatchedBySameUser: <span class="type">RDD</span>[(<span class="type">Int</span>, ((<span class="type">Int</span>, <span class="type">Double</span>), (<span class="type">Int</span>, <span class="type">Double</span>)))] = userIdMappedWithMovieIdAndRatings.join(userIdMappedWithMovieIdAndRatings)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察数据</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(94,2.0)))</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(78,1.0)))</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(7,4.0)))</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    pairOfMoviesWatchedBySameUser.take(<span class="number">3</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于上面的join操作，会出现重复数据，我们只需要无重复的两两组合</span></span><br><span class="line">    <span class="keyword">val</span> pairOfMoviesWithoutDuplicates: <span class="type">RDD</span>[(<span class="type">Int</span>, ((<span class="type">Int</span>, <span class="type">Double</span>), (<span class="type">Int</span>, <span class="type">Double</span>)))] = pairOfMoviesWatchedBySameUser.filter(filterDuplicateMovieData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察数据</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(1273,3.0)))</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(265,4.0)))</span></span><br><span class="line"><span class="comment">      * (778,((94,2.0),(239,4.0)))</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    pairOfMoviesWithoutDuplicates.take(<span class="number">3</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对上述的RDD进行map操作，加工成形如(movie1,movie2) =&gt; (rating1,rating2)</span></span><br><span class="line">    <span class="keyword">val</span> moviePairAndRatings: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Double</span>))] = pairOfMoviesWithoutDuplicates.map(mapMoviePairsWithRatings)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察数据</span></span><br><span class="line"><span class="comment">      * ((94,1273),(2.0,3.0))</span></span><br><span class="line"><span class="comment">      * ((94,265),(2.0,4.0))</span></span><br><span class="line"><span class="comment">      * ((94,239),(2.0,4.0))</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    moviePairAndRatings.take(<span class="number">3</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Combining all the same movie sets with their ratings</span></span><br><span class="line">    <span class="comment">// 对上述的RDD按照key进行分组，这样相同的key，</span></span><br><span class="line">    <span class="comment">// 即相同组合的电影对应的评分就构成了电影的评分矩阵</span></span><br><span class="line">    <span class="keyword">val</span> groupOfRatingPairsForSameMoviePair: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), <span class="type">Iterable</span>[(<span class="type">Double</span>, <span class="type">Double</span>)])] = moviePairAndRatings.groupByKey()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察数据</span></span><br><span class="line"><span class="comment">      * ((220,977),CompactBuffer((1.0,2.0), (3.0,4.0), (2.0,3.0), (5.0,3.0), (2.0,1.0), (4.0,1.0)))</span></span><br><span class="line"><span class="comment">      * 评分矩阵的形式为：</span></span><br><span class="line"><span class="comment">      * |movie220|movie977|</span></span><br><span class="line"><span class="comment">      * -------------------</span></span><br><span class="line"><span class="comment">      * |1.0     |2.0     |</span></span><br><span class="line"><span class="comment">      * |3.0     |4.0     |</span></span><br><span class="line"><span class="comment">      * |2.0     |3.0     |</span></span><br><span class="line"><span class="comment">      * |5.0     |3.0     |</span></span><br><span class="line"><span class="comment">      * |2.0     |1.0     |</span></span><br><span class="line"><span class="comment">      * |4.0     |1.0     |</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    groupOfRatingPairsForSameMoviePair.take(<span class="number">1</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据上面的评分矩阵，计算两两电影组合的评分矩阵</span></span><br><span class="line">    <span class="comment">// 注：mapValues算子仅作用在value上,不会改变key的值，依然返回(key,value)的形式</span></span><br><span class="line">    <span class="keyword">val</span> moviePairsAndSimilarityScore: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">Double</span>, <span class="type">Int</span>))] = groupOfRatingPairsForSameMoviePair.mapValues(computeCosineSimilarity)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 打印该RDD数据，便于观察数据</span></span><br><span class="line"><span class="comment">      * ((220,977),(0.9082259841451907,9))</span></span><br><span class="line"><span class="comment">      * ((876,977),(0.9701425001453319,5))</span></span><br><span class="line"><span class="comment">      * ((742,758),(0.8905344810811052,13))</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    moviePairsAndSimilarityScore.take(<span class="number">3</span>).foreach(println(_))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据余弦相似度计算相似的电影，打印电影推荐列表</span></span><br><span class="line">    <span class="comment">// args为传入的电影id参数</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      suggestTop10Movies(moviePairsAndSimilarityScore, args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      println(<span class="string">"请输入电影id"</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文使用基于物品的协同过滤算法，在MovieLens数据集上通过SparkRDD实现了一个简单的推荐系统，并给出了详细的代码示例，你可以对此进行调试，一方面可以了解经典的推荐系统基本原理，另一方面也可以对SparkRDD编程有更加深刻的认识。</p>
<blockquote>
<p>公众号『大数据技术与数仓』，回复『资料』领取大数据资料包</p>
</blockquote>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/12/18/Flink集成Hive之快速入门-以Flink1-12为例/" target="_blank">Flink集成Hive之快速入门--以Flink1.12为例</a></li><li><a href="https://jiamaoxiang.top/2020/12/15/使用自定义分区器解决Spark-DataSet数据分区不均匀的问题/" target="_blank">使用自定义分区器解决Spark DataSet数据分区不均匀的问题</a></li><li><a href="https://jiamaoxiang.top/2020/12/06/如何管理Spark的分区/" target="_blank">如何管理Spark的分区</a></li><li><a href="https://jiamaoxiang.top/2020/11/26/数仓开发需要了解的5大SQL分析函数/" target="_blank">数仓开发需要了解的5大SQL分析函数</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/12/11/秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建/">https://jiamaoxiang.top/2020/12/11/秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/12/11/秒懂推荐系统-Spark平台下基于物品的协同过滤推荐系统构建/" data-id="cko9nihzo005f5k7q1wq9ebws" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD7UlEQVR42u3aS3LqUAwFQPa/6WT6ql5szpGuKQbtUSqAfdUMhD6vV3z9XFz/vpp89uo/V0+5v//mVKsLBw4cOHCMQk0C+P8+7fuvApihJ1/AVYw4cODAgeMsx6nwkiyWZLecbEOJAwcOHDi+h2NfLLVB3v/n/p04cODAgeP7OTZBtlhJKzA/CQ4cOHDg+AxHO8LZF3VtIzJvJn6oV4oDBw4cONJceaDc+ra/D184cODAgSNOdcl1n/bu09j9+2flXJ5038SFAwcOHDjWHPn4vw1jFvYmoSbFJw4cOHDg+CTHfUXTHiIPYNa8y0di9SoGDhw4cOBYcOSttCTsPD234W1GYsVwCwcOHDhwrDlyiLzYy0c+bctv9iUlqRcHDhw4cJziaKu9diiVHyt5VlsW5gt5f0zhcODAgQPHiGN2rH1ibpckZik/p1l9Szhw4MCBI6hZ2hudHT4lhV/+g6D4LA4cOHDgOMqRD4Rm63T5esRrcbWNwlf7swQHDhw4cMS3aEc1Z9t2M+72WVG8OHDgwIFjwbEpzJK0vSGYNRBXWDhw4MCBY82RB9OGMSvqzgK14zEcOHDgwHGWox3w5I3FzarBc+3LA31HHDhw4MART1tasnYQ1d5zs8QwHLnhwIEDB441x9lU2g6u2vBmzcoaDgcOHDhwLDja9YJZSdYm6Xb1rW1Z4sCBAweOJzjahYYkZbZFV76ul6fb2XALBw4cOHBsOPKjzI7VNuzaNuVmqvbH2XDgwIEDxyGO2SAnWXprE3M+ssoTc9EixIEDBw4ca448HSYFWN6wa0dNbSm4Wt3DgQMHDhwLjqQ9twm1bRrmzb7ZEOtN+YcDBw4cOB7mSBJkjjgr8DbvbIdYOHDgwIFjzzFbBcjTak4zS/abtYmCBgcOHDhwxBz7dDgrn06tJmyKw9WqHA4cOHDguH316SSXEJz6bN5qjIxx4MCBA0fJMWv2tQ3BvKzKy8J9cVj/7sCBAwcOHCVHDtG2C0+VXi1Q/vThfgcOHDhw4Ag48hIoP1y7JNEu3iUrcVG5iAMHDhw4DnG0Ac9WGTaF3KZ3ly/V4cCBAweOPUf+1llRl5dVTyTy4Z1x4MCBA8eCY58+kwW7pLjKh0/tNkKedHHgwIEDx57j1BbZbE0tL8DyCisp8JK74cCBAweODUeeXPPj5mRt2p41BIsSFAcOHDhwHOJIAtsc/WxSn6X2NwMnHDhw4MDxcY58DaItvdpkOfuJcDjR4sCBAweOQzVLm5Wi9Fam6nZIVjwdBw4cOHAc4miXGNqR0mqBIC4p26HXqleKAwcOHDjSrbP6KG0Zlh+ivX/eXtw0FnHgwIEDx0VEv/5Wucw5DbolAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Spark/">Spark</a></div><div class="post-nav"><a class="pre" href="/2020/12/15/使用自定义分区器解决Spark-DataSet数据分区不均匀的问题/">使用自定义分区器解决Spark DataSet数据分区不均匀的问题</a><a class="next" href="/2020/12/06/如何管理Spark的分区/">如何管理Spark的分区</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于物品的协同过滤算法原理"><span class="toc-number">1.</span> <span class="toc-text">基于物品的协同过滤算法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据集准备"><span class="toc-number">2.</span> <span class="toc-text">数据集准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现"><span class="toc-number">3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2021 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>