<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Flink DataStream API编程指南 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink DataStream API编程指南</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink DataStream API编程指南</h1><div class="post-meta">Apr 12, 2020<span> | </span><span class="category"><a href="/categories/Flink/">Flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Flink DataStream API主要分为三个部分，分别为Source、Transformation以及Sink，其中Source是数据源，Flink内置了很多数据源，比如最常用的Kafka。Transformation是具体的转换操作，主要是用户定义的处理数据的逻辑，比如Map，FlatMap等。Sink(数据汇)是数据的输出，可以把处理之后的数据输出到存储设备上，Flink内置了许多的Sink，比如Kafka，HDFS等。另外除了Flink内置的Source和Sink外，用户可以实现自定义的Source与Sink。考虑到内置的Source与Sink使用起来比较简单且方便，所以，关于内置的Source与Sink的使用方式不在本文的讨论范围之内，本文会先从自定义Source开始说起，然后详细描述一些常见算子的使用方式，最后会实现一个自定义的Sink。</p>
<a id="more"></a>

<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>Flink内部实现了比较常用的数据源，比如基于文件的，基于Socket的，基于集合的等等，如果这些都不能满足需求，用户可以自定义数据源，下面将会以MySQL为例，实现一个自定义的数据源。本文的所有操作将使用该数据源，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Created</span> with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> : jmx</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/14</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Time</span>: 17:34</span></span><br><span class="line"><span class="comment"> * note: RichParallelSourceFunction与SourceContext必须加泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlSource</span> <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>&lt;<span class="title">UserBehavior</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Connection conn;</span><br><span class="line">    <span class="keyword">public</span> PreparedStatement pps;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String pass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法只会在最开始的时候被调用一次</span></span><br><span class="line"><span class="comment">     * 此方法用于实现获取连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化数据库连接参数</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        URL fileUrl = TestProperties.class.getClassLoader().getResource(<span class="string">"mysql.ini"</span>);</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileUrl.toURI()));</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">        driver = properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        pass = properties.getProperty(<span class="string">"pass"</span>);</span><br><span class="line">        <span class="comment">//获取数据连接</span></span><br><span class="line">        conn = getConection();</span><br><span class="line">        String scanSQL = <span class="string">"SELECT * FROM user_behavior_log"</span>;</span><br><span class="line">        pps = conn.prepareStatement(scanSQL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;UserBehavior&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ResultSet resultSet = pps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            ctx.collect(UserBehavior.of(</span><br><span class="line">                    resultSet.getLong(<span class="string">"user_id"</span>),</span><br><span class="line">                    resultSet.getLong(<span class="string">"item_id"</span>),</span><br><span class="line">                    resultSet.getInt(<span class="string">"cat_id"</span>),</span><br><span class="line">                    resultSet.getInt(<span class="string">"merchant_id"</span>),</span><br><span class="line">                    resultSet.getInt(<span class="string">"brand_id"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"action"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"gender"</span>),</span><br><span class="line">                    resultSet.getLong(<span class="string">"timestamp"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connnection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//获取连接</span></span><br><span class="line">            connnection = DriverManager.getConnection(</span><br><span class="line">                    url,</span><br><span class="line">                    user,</span><br><span class="line">                    pass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connnection;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先继承RichParallelSourceFunction，实现继承的方法，主要包括open()方法、run()方法及close方法。上述的</p>
<p>RichParallelSourceFunction是支持设置多并行度的，关于RichParallelSourceFunction与RichSourceFunction的区别，前者支持用户设置多并行度，后者不支持通过setParallelism()方法设置并行度，默认的并行度为1，否则会报如下错误：<figure class="highlight plain"><figcaption><span>in thread "main" java.lang.IllegalArgumentException: The maximum parallelism of non parallel operator must be 1.```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">另外，RichParallelSourceFunction提供了额外的open()方法与close()方法，如果定义Source时需要获取链接，那么可以在open()方法中进行初始化，然后在close()方法中关闭资源链接，关于Rich***Function与普通Function的区别，下文会详细解释，在这里先有个印象。上述的代码中的配置信息是通过配置文件传递的，由于篇幅限制，我会把本文的代码放置在github，见文末github地址。</span><br><span class="line"></span><br><span class="line">## 基本转换</span><br><span class="line"></span><br><span class="line">Flink提供了大量的算子操作供用户使用，常见的算子主要包括以下几种，注意：本文不讨论关于基于时间与窗口的算子，这些内容会在《Flink基于时间与窗口的算子》中进行详细介绍。</span><br><span class="line"></span><br><span class="line">**说明**：本文的操作是基于上文自定义的MySQL Source，对应的数据解释如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">userId;     // 用户ID</span><br><span class="line">itemId;     // 商品ID</span><br><span class="line">catId;      // 商品类目ID</span><br><span class="line">merchantId; // 卖家ID</span><br><span class="line">brandId;    // 品牌ID</span><br><span class="line">action;     // 用户行为, 包括(&quot;pv&quot;, &quot;buy&quot;, &quot;cart&quot;, &quot;fav&quot;)</span><br><span class="line">gender;     // 性别</span><br><span class="line">timestamp;  // 行为发生的时间戳，单位秒</span><br></pre></td></tr></table></figure></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p> DataStream → DataStream 的转换，输入一个元素，返回一个元素，如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;String&gt; userBehaviorMap = userBehavior.map(<span class="keyword">new</span> RichMapFunction&lt;UserBehavior, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(UserBehavior value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String action = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">switch</span> (value.action) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"pv"</span>:</span><br><span class="line">                        action = <span class="string">"浏览"</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"cart"</span>:</span><br><span class="line">                        action = <span class="string">"加购"</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"fav"</span>:</span><br><span class="line">                        action = <span class="string">"收藏"</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"buy"</span>:</span><br><span class="line">                        action = <span class="string">"购买"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> action;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p>将雨滴形状转换成相对应的圆形形状的map操作</p>
<p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/map.png" alt></p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>DataStream → DataStream，输入一个元素，返回零个、一个或多个元素。事实上，flatMap算子可以看做是filter与map的泛化，即它能够实现这两种操作。flatMap算子对应的FlatMapFunction定义了flatMap方法，可以通过向collector对象传递数据的方式返回0个，1个或者多个事件作为结果。如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;UserBehavior&gt; userBehaviorflatMap = userBehavior.flatMap(<span class="keyword">new</span> RichFlatMapFunction&lt;UserBehavior, UserBehavior&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(UserBehavior value, Collector&lt;UserBehavior&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (value.gender.equals(<span class="string">"女"</span>)) &#123;</span><br><span class="line">                    out.collect(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="示意图-1"><a href="#示意图-1" class="headerlink" title="示意图"></a>示意图</h4><p>将黄色的雨滴过滤掉，将蓝色雨滴转为圆形，保留绿色雨滴</p>
<p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/flatmap.png" alt></p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>DataStream → DataStream，过滤算子，对数据进行判断，符合条件即返回true的数据会被保留，否则被过滤。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;UserBehavior&gt; userBehaviorFilter = userBehavior.filter(<span class="keyword">new</span> RichFilterFunction&lt;UserBehavior&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(UserBehavior value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> value.action.equals(<span class="string">"buy"</span>);<span class="comment">//保留购买行为的数据</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="示意图-2"><a href="#示意图-2" class="headerlink" title="示意图"></a>示意图</h4><p>将红色与绿色雨滴过滤掉，保留蓝色雨滴。</p>
<p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/filter.png" alt></p>
<h3 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h3><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><p>DataStream→KeyedStream，从逻辑上将流划分为不相交的分区。具有相同键的所有记录都分配给同一分区。在内部，keyBy（）是通过哈希分区实现的。<br>定义键值有3中方式：<br>(1)使用字段位置，如keyBy(1)，此方式是针对元组数据类型，比如tuple，使用元组相应元素的位置来定义键值;<br>(2)字段表达式,用于元组、POJO以及样例类;<br>(3)键值选择器，即keySelector，可以从输入事件中提取键值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; userBehaviorkeyBy = userBehavior.map(<span class="keyword">new</span> RichMapFunction&lt;UserBehavior, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(UserBehavior value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(value.action.toString(), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).keyBy(<span class="number">0</span>) <span class="comment">// scala元组编号从1开始，java元组编号是从0开始</span></span><br><span class="line">           .sum(<span class="number">1</span>); <span class="comment">//滚动聚合</span></span><br></pre></td></tr></table></figure>

<h4 id="示意图-3"><a href="#示意图-3" class="headerlink" title="示意图"></a>示意图</h4><p>基于形状对事件进行分区的keyBy操作</p>
<p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/keyBy.png" alt></p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><h4 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h4><p>KeyedStream → DataStream，对数据进行滚动聚合操作，结合当前元素和上一次Reduce返回的值进行聚合，然后返回一个新的值.将一个ReduceFunction应用在一个keyedStream上,每到来一个事件都会与当前reduce的结果进行聚合，<br>产生一个新的DataStream,该算子不会改变数据类型，因此输入流与输出流的类型永远保持一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; userBehaviorReduce = userBehavior.map(<span class="keyword">new</span> RichMapFunction&lt;UserBehavior, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(UserBehavior value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(value.action.toString(), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).keyBy(<span class="number">0</span>) <span class="comment">// scala元组编号从1开始，java元组编号是从0开始</span></span><br><span class="line">          .reduce(<span class="keyword">new</span> RichReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; value1, Tuple2&lt;String, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> Tuple2.of(value1.f0,value1.f1 + value2.f1);<span class="comment">//滚动聚合,功能与sum类似</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="示意图-4"><a href="#示意图-4" class="headerlink" title="示意图"></a>示意图</h4><p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/reduce.png" alt></p>
<h3 id="Aggregations-滚动聚合"><a href="#Aggregations-滚动聚合" class="headerlink" title="Aggregations(滚动聚合)"></a>Aggregations(滚动聚合)</h3><p>KeyedStream → DataStream，Aggregations(滚动聚合),滚动聚合转换作用于KeyedStream流上，生成一个包含聚合结果(比如sum求和，min最小值)的DataStream，滚动聚合的转换会为每个流过该算子的key值保存一个聚合结果，<br>当有新的元素流过该算子时，会根据之前的结果值和当前的元素值，更新相应的结果值</p>
<ul>
<li><p>sum():滚动聚合流过该算子的指定字段的和；</p>
</li>
<li><p>min():滚动计算流过该算子的指定字段的最小值</p>
</li>
<li><p>max():滚动计算流过该算子的指定字段的最大值</p>
</li>
<li><p>minBy():滚动计算当目前为止流过该算子的最小值，返回该值对应的事件；</p>
</li>
<li><p>maxBy():滚动计算当目前为止流过该算子的最大值，返回该值对应的事件；</p>
</li>
</ul>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><h4 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h4><p>DataStream* → DataStream，将多条流合并，新的的流会包括所有流的数据，值得注意的是，两个流的数据类型必须一致，另外，来自两条流的事件会以FIFO(先进先出)的方式合并，所以并不能保证两条流的顺序，此外，union算子不会对数据去重，每个输入事件都会被发送到下游算子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userBehaviorkeyBy.union(userBehaviorReduce).print();<span class="comment">//将两条流union在一起，可以支持多条流(大于2)的union</span></span><br></pre></td></tr></table></figure>

<h4 id="示意图-5"><a href="#示意图-5" class="headerlink" title="示意图"></a>示意图</h4><p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/union.png" alt></p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><h4 id="解释-6"><a href="#解释-6" class="headerlink" title="解释"></a>解释</h4><p>DataStream,DataStream → ConnectedStreams，将两个流的事件进行组合，返回一个ConnectedStreams对象，两个流的数据类型可以不一致,ConnectedStreams对象提供了类似于map(),flatMap()功能的算子，如CoMapFunction与CoFlatMapFunction分别表示map()与flatMap算子，这两个算子会分别作用于两条流，注意：CoMapFunction 或CoFlatMapFunction被调用的时候并不能控制事件的顺序只要有事件流过该算子，该算子就会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectedStreams&lt;UserBehavior, Tuple2&lt;String, Integer&gt;&gt; behaviorConnectedStreams = userBehaviorFilter.connect(userBehaviorkeyBy);</span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Integer&gt;&gt; behaviorConnectedStreamsmap = behaviorConnectedStreams.map(<span class="keyword">new</span> RichCoMapFunction&lt;UserBehavior, Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Integer&gt; <span class="title">map1</span><span class="params">(UserBehavior value1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple3.of(<span class="string">"first"</span>, value1.action, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Integer&gt; <span class="title">map2</span><span class="params">(Tuple2&lt;String, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple3.of(<span class="string">"second"</span>, value2.f0, value2.f1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><h4 id="解释-7"><a href="#解释-7" class="headerlink" title="解释"></a>解释</h4><p>DataStream → SplitStream，将流分割成两条或多条流，与union相反。分割之后的流与输入流的数据类型一致，<br>对于每个到来的事件可以被路由到0个、1个或多个输出流中。可以实现过滤与复制事件的功能，DataStream.split()接收一个OutputSelector函数，用来定义分流的规则，即将满足不同条件的流分配到用户命名的一个输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> SplitStream&lt;UserBehavior&gt; userBehaviorSplitStream = userBehavior.split(<span class="keyword">new</span> OutputSelector&lt;UserBehavior&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(UserBehavior value)</span> </span>&#123;</span><br><span class="line">                ArrayList&lt;String&gt; userBehaviors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">if</span> (value.action.equals(<span class="string">"buy"</span>)) &#123;</span><br><span class="line">                    userBehaviors.add(<span class="string">"buy"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    userBehaviors.add(<span class="string">"other"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> userBehaviors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">userBehaviorSplitStream.select(<span class="string">"buy"</span>).print();</span><br></pre></td></tr></table></figure>

<h4 id="示意图-6"><a href="#示意图-6" class="headerlink" title="示意图"></a>示意图</h4><p><img src="//jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/split.png" alt></p>
<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>Flink提供了许多内置的Sink，比如writeASText，print，HDFS，Kaka等等，下面将基于MySQL实现一个自定义的Sink，可以与自定义的MysqlSource进行对比，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Created</span> with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> : jmx</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/16</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Time</span>: 22:53</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlSink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">UserBehavior</span>&gt; </span>&#123;</span><br><span class="line">    PreparedStatement pps;</span><br><span class="line">    <span class="keyword">public</span> Connection conn;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String pass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在open() 方法初始化连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化数据库连接参数</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        URL fileUrl = TestProperties.class.getClassLoader().getResource(<span class="string">"mysql.ini"</span>);</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileUrl.toURI()));</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">        driver = properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        pass = properties.getProperty(<span class="string">"pass"</span>);</span><br><span class="line">        <span class="comment">//获取数据连接</span></span><br><span class="line">        conn = getConnection();</span><br><span class="line">        String insertSql = <span class="string">"insert into user_behavior values(?, ?, ?, ?,?, ?, ?, ?);"</span>;</span><br><span class="line">        pps = conn.prepareStatement(insertSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用invoke() 方法，进行数据插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(UserBehavior value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        pps.setLong(<span class="number">1</span>, value.userId);</span><br><span class="line">        pps.setLong(<span class="number">2</span>, value.itemId);</span><br><span class="line">        pps.setInt(<span class="number">3</span>, value.catId);</span><br><span class="line">        pps.setInt(<span class="number">4</span>, value.merchantId);</span><br><span class="line">        pps.setInt(<span class="number">5</span>, value.brandId);</span><br><span class="line">        pps.setString(<span class="number">6</span>, value.action);</span><br><span class="line">        pps.setString(<span class="number">7</span>, value.gender);</span><br><span class="line">        pps.setLong(<span class="number">8</span>, value.timestamp);</span><br><span class="line">        pps.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connnection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//获取连接</span></span><br><span class="line">            connnection = DriverManager.getConnection(</span><br><span class="line">                    url,</span><br><span class="line">                    user,</span><br><span class="line">                    pass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connnection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于RichFunction"><a href="#关于RichFunction" class="headerlink" title="关于RichFunction"></a>关于RichFunction</h2><p>细心的读者可以发现，在前文的算子操作案例中，使用的都是RichFunction，因为在很多时候需要在函数处理数据之前先进行一些初始化操作，或者获取函数的上下文信息，DataStream API提供了一类RichFunction，与普通的函数相比，该函数提供了许多额外的功能。</p>
<p>使用RichFunction的时候，可以实现两个额外的方法：</p>
<ul>
<li>open(),是初始化方法，会在每个人物首次调用转换方法(比如map)前调用一次。通常用于进行一次的设置工作，注意Configuration参数只在DataSet API中使用，而并没有在DataStream API中使用，因此在使用DataStream API时，可以将其忽略。</li>
<li>close()，函数的终止方法 ，会在每个任务最后一次调用转换方法后调用一次，通常用于资源释放等操作。</li>
</ul>
<p>此外用户还可以通过getRuntimeContext()方法访问函数的上下文信息(RuntimeContext),例如函数的并行度，函数所在subtask的编号以及执行函数的任务名称，同时也可以访问分区状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先实现了自定义MySQL Source，然后基于MySql 的Source进行了一系列的算子操作，并对常见的算子操作进行详细剖析，最后实现了一个自定义MySQL Sink，并对RichFunction进行了解释。</p>
<p><strong>代码地址</strong>:<a href="https://github.com/jiamx/study-flink" target="_blank" rel="noopener">https://github.com/jiamx/study-flink</a></p>
<blockquote>
<p>公众号『大数据技术与数仓』，回复『资料』领取大数据资料包</p>
</blockquote>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/" target="_blank">Flink内部Exactly Once三板斧:状态、状态后端与检查点</a></li><li><a href="https://jiamaoxiang.top/2020/04/17/Flink基于时间与窗口的算子/" target="_blank">Flink的时间与watermarks详解</a></li><li><a href="https://jiamaoxiang.top/2020/04/09/如何使用Hive进行OLAP分析/" target="_blank">如何使用Hive进行OLAP分析</a></li><li><a href="https://jiamaoxiang.top/2020/04/02/你真的了解Flink-Kafka-connector吗？/" target="_blank">你真的了解Flink Kafka source吗？</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/04/12/Flink-DataStream-API编程指南/">https://jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/" data-id="ckhlrt6c4004vgo7qlzzt3wzy" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuklEQVR42u3a204DMQwFQP7/p0HiCanscmzHbZFmn9D2spkgJemxPz7i6/P7ur/z8/7PVx/vJPeTMRy78PDw8FpDv7qSQeekx4FefUM+ZX98Ax4eHt4aLx9EbxG/H8Tjs+4/Vdg88PDw8F7Ky7eE6jurx3o8PDy8/8jLE4BTeQkeHh7eu/F6y31+BL8f3Gd8LWYteHh4eDFvsii/6u/F+h4eHh7eoKo+KU1NSmvHRouHh4e3wJsUmfJDc950NTkWF34x4OHh4Q14yQYwweQTNHnn5djw8PDw1ninhpUv9HkEfL9J/PFEPDw8vDVe8rDqgn4qMk4C3Mv34+Hh4T2FlxT4q1FF3pTQC3ajdis8PDy8Q7xJeakaT+Tl/2p8HB3E8fDw8NZ4k2Nu3kaQ3Jm3F+Dh4eE9h5c8Mol651OWPzcKL/Dw8PCO8iaFq+oyXW3w6h2+K1UyPDw8vA4vjySqi3gyWb1gNzma4+Hh4T2Hl6+ovdJUNd7tNYHh4eHh7fHycCFfmvNQ42yV/5fJxcPDw1vg9X7e54OuLv2TyDgqleHh4eGNeZO2qjwmyMH5FhWNAQ8PD2+Bl0SivQNxtbTWizOiKcDDw8M7yqu2C0wGly/rhf/M/Qjx8PDwFnjzx+Shau9+L4wozA0eHh7egFdtZtqLFfJWhvKhHw8PD2/Mq3ZjTULb3oLeeyIeHh7eM3n5TpIXyfL4tUdt9pTh4eHhtXj5gbX66v1Q8oP7yoWHh4c3ZvRar041rVZfTZ5e7inDw8PDi3nzraIavCYTl+Dx8PDwXsvrbQbV5btQhWttP5eTjoeHh7fGm0Sr+RCrAcSBYAIPDw/vpbxqYDFvDsg/e7lh4OHh4b0Bb36Yzgc3+TY8PDy8bV4eRvQapKrbwLGNBA8PD2+BV/1Fn9fT8vJVtTErmQg8PDy8Bd4XUNMNATk+nUAAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2020/04/17/Flink基于时间与窗口的算子/">Flink的时间与watermarks详解</a><a class="next" href="/2020/04/09/如何使用Hive进行OLAP分析/">如何使用Hive进行OLAP分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据源"><span class="toc-number">1.</span> <span class="toc-text">数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">1.1.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释"><span class="toc-number">1.1.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图"><span class="toc-number">1.1.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-number">1.2.</span> <span class="toc-text">flatMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter"><span class="toc-number">1.3.</span> <span class="toc-text">Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyBy"><span class="toc-number">1.4.</span> <span class="toc-text">keyBy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce"><span class="toc-number">1.5.</span> <span class="toc-text">Reduce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aggregations-滚动聚合"><span class="toc-number">1.6.</span> <span class="toc-text">Aggregations(滚动聚合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union"><span class="toc-number">1.7.</span> <span class="toc-text">union</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">1.8.</span> <span class="toc-text">connect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-6"><span class="toc-number">1.8.1.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split"><span class="toc-number">1.9.</span> <span class="toc-text">split</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释-7"><span class="toc-number">1.9.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示意图-6"><span class="toc-number">1.9.2.</span> <span class="toc-text">示意图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sink"><span class="toc-number">2.</span> <span class="toc-text">Sink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于RichFunction"><span class="toc-number">3.</span> <span class="toc-text">关于RichFunction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>