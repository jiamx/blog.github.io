<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Flink内部Exactly Once三板斧:状态、状态后端与检查点 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink内部Exactly Once三板斧:状态、状态后端与检查点</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink内部Exactly Once三板斧:状态、状态后端与检查点</h1><div class="post-meta">Apr 25, 2020<span> | </span><span class="category"><a href="/categories/Flink/">Flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 29</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Flink是一个分布式的流处理引擎，而流处理的其中一个特点就是7X24。那么，如何保障Flink作业的持续运行呢？Flink的内部会将应用状态(state)存储到本地内存或者嵌入式的kv数据库(RocksDB)中，由于采用的是分布式架构，Flink需要对本地生成的状态进行持久化存储，以避免因应用或者节点机器故障等原因导致数据的丢失，Flink是通过checkpoint(检查点)的方式将状态写入到远程的持久化存储，从而就可以实现不同语义的结果保障。通过本文，你可以了解到什么是Flink的状态，Flink的状态是怎么存储的，Flink可选择的状态后端(statebackend)有哪些，什么是全局一致性检查点，Flink内部如何通过检查点实现Exactly Once的结果保障。另外，本文内容较长，建议关注加收藏。</p>
<a id="more"></a>

<h2 id="什么是状态"><a href="#什么是状态" class="headerlink" title="什么是状态"></a>什么是状态</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>关于什么是状态，我们先不做过多的分析。首先看一个代码案例，其中案例1是Spark的WordCount代码，案例2是Flink的WorkCount代码。</p>
<ul>
<li>案例1：Spark WC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object WordCount &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args:Array[String])</span></span>&#123;</span><br><span class="line">  val conf = <span class="keyword">new</span> SparkConf().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"NetworkWordCount"</span>)</span><br><span class="line">  val ssc = <span class="keyword">new</span> StreamingContext(conf, Seconds(<span class="number">5</span>))</span><br><span class="line">  val lines = ssc.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>)</span><br><span class="line">  val words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">  val pairs = words.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line">  val wordCounts = pairs.reduceByKey(_ + _)</span><br><span class="line">  wordCounts.print()</span><br><span class="line">  ssc.start()</span><br><span class="line">  ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;nc -lp 9999</span><br><span class="line">hello spark</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/spark.png" alt></p>
<ul>
<li>案例2：Flink WC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        DataStreamSource&lt;String&gt; streamSource = env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String,Integer&gt;&gt; words = streamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String,Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] splits = value.split(<span class="string">"\\s"</span>);</span><br><span class="line">                <span class="keyword">for</span> (String word : splits) &#123;</span><br><span class="line">                    out.collect(Tuple2.of(word, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        words.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print();</span><br><span class="line">        env.execute(<span class="string">"WC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;nc -lp <span class="number">9999</span></span><br><span class="line">hello Flink</span><br><span class="line">hello Flink</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/Flink.png" alt></p>
<p>从上面的两个例子可以看出，在使用Spark进行词频统计时，当前的统计结果不受历史统计结果的影响，只计算接收的当前数据的结果，这个就可以理解为无状态的计算。再来看一下Flink的例子，可以看出当第二次词频统计时，把第一次的结果值也统计在了一起，即Flink把上一次的计算结果保存在了状态里，第二次计算的时候会先拿到上一次的结果状态，然后结合新到来的数据再进行计算，这就可以理解成有状态的计算，如下图所示。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/statetask.png" alt></p>
<h3 id="状态的类别"><a href="#状态的类别" class="headerlink" title="状态的类别"></a>状态的类别</h3><p>Flink提供了两种基本类型的状态：分别是 <code>Keyed State</code> 和<code>Operator State</code>。根据不同的状态管理方式，每种状态又有两种存在形式，分别为：<code>managed(托管状态)</code>和<code>raw(原生状态)</code>。具体如下表格所示。需要注意的是，由于Flink推荐使用managed state，所以下文主要讨论managed state，对于raw state，本文不会做过多的讨论。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/state_kinds.png" alt></p>
<h4 id="managed-state-amp-raw-state区别"><a href="#managed-state-amp-raw-state区别" class="headerlink" title="managed state &amp; raw state区别"></a>managed state &amp; raw state区别</h4><p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/managedstate_rowstate.png" alt></p>
<h4 id="Keyed-State-amp-Operator-State"><a href="#Keyed-State-amp-Operator-State" class="headerlink" title="Keyed State &amp; Operator State"></a>Keyed State &amp; Operator State</h4><p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/keystate_operatorstate.png" alt></p>
<h3 id="Keyed-State"><a href="#Keyed-State" class="headerlink" title="Keyed State"></a>Keyed State</h3><p>Keyed State只能由作用在KeyedStream上面的函数使用，该状态与某个key进行绑定，即每一个key对应一个state。Keyed State按照key进行维护和访问的，Flink会为每一个Key都维护一个状态实例，该状态实例总是位于处理该key记录的算子任务上，因此同一个key的记录可以访问到一样的状态。如下图所示，可以通过在一条流上使用keyBy()方法来生成一个KeyedStream。Flink提供了很多种keyed state，具体如下：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/keyedstate.png" alt></p>
<ul>
<li><strong>ValueState<t></t></strong></li>
</ul>
<p>用于保存类型为T的单个值。用户可以通过ValueState.value()来获取该状态值，通过ValueState.update()来更新该状态。使用<code>ValueStateDescriptor</code>来获取状态句柄。</p>
<ul>
<li><strong>ListState<t></t></strong></li>
</ul>
<p>用于保存类型为T的元素列表，即key的状态值是一个列表。用户可以使用ListState.add()或者ListState.addAll()将新元素添加到列表中，通过ListState.get()访问状态元素，该方法会返回一个可遍历所有元素的Iterable<t>对象，注意ListState不支持删除单个元素，但是用户可以使用update(List<t> values)来更新整个列表。使用 <code>ListStateDescriptor</code>来获取状态句柄。</t></t></p>
<ul>
<li><strong>ReducingState<t></t></strong></li>
</ul>
<p>调用add()方法添加值时，会立即返回一个使用ReduceFunction聚合后的值，用户可以使用ReducingState.get()来获取该状态值。使用 <code>ReducingStateDescriptor</code>来获取状态句柄。</p>
<ul>
<li><strong>AggregatingState&lt;IN, OUT&gt;</strong></li>
</ul>
<p>与ReducingState<t>类似，不同的是它使用的是AggregateFunction来聚合内部的值，AggregatingState.get()方法会计算最终的结果并将其返回。使用 <code>AggregatingStateDescriptor</code>来获取状态句柄</t></p>
<ul>
<li><strong>MapState&lt;UK, UV&gt;</strong></li>
</ul>
<p>用于保存一组key、value的映射，类似于java的Map集合。用户可以通过get(UK key)方法获取key对应的状态，可以通过put(UK k,UV value)方法添加一个键值，可以通过remove(UK key)删除给定key的值，可以通过contains(UK key)判断是否存在对应的key。使用 <code>MapStateDescriptor</code>来获取状态句柄。</p>
<ul>
<li><strong>FoldingState&lt;T, ACC&gt;</strong></li>
</ul>
<p>在Flink 1.4的版本中标记过时，在未来的版本中会被移除，使用AggregatingState进行代替。</p>
<p>值得注意的是，上面的状态原语都支持通过State.clear()方法来进行清除状态。另外，上述的状态原语仅用于与状态进行交互，真正的状态是存储在状态后端（后面会介绍状态后端）的，通过该状态原语相当于持有了状态的句柄(handle)。</p>
<h4 id="keyed-State使用案例"><a href="#keyed-State使用案例" class="headerlink" title="keyed State使用案例"></a>keyed State使用案例</h4><p>下面给出一个MapState的使用案例，关于ValueState的使用情况可以参考官网，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapStateExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计每个用户每种行为的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBehaviorCnt</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个MapState句柄</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> MapState&lt;String, Integer&gt; behaviorCntState;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.open(parameters);</span><br><span class="line">            MapStateDescriptor&lt;String, Integer&gt; userBehaviorMapStateDesc = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">                    <span class="string">"userBehavior"</span>,  <span class="comment">// 状态描述符的名称</span></span><br><span class="line">                    TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;String&gt;() &#123;&#125;),  <span class="comment">// MapState状态的key的数据类型</span></span><br><span class="line">                    TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Integer&gt;() &#123;&#125;)  <span class="comment">// MapState状态的value的数据类型</span></span><br><span class="line">            );</span><br><span class="line">            behaviorCntState = getRuntimeContext().getMapState(userBehaviorMapStateDesc); <span class="comment">// 获取状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Tuple3&lt;Long, String, String&gt; value, Collector&lt;Tuple3&lt;Long, String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Integer behaviorCnt = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前状态包括该行为，则+1</span></span><br><span class="line">            <span class="keyword">if</span> (behaviorCntState.contains(value.f1)) &#123;</span><br><span class="line">                behaviorCnt = behaviorCntState.get(value.f1) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新状态</span></span><br><span class="line">            behaviorCntState.put(value.f1, behaviorCnt);</span><br><span class="line">            out.collect(Tuple3.of(value.f0, value.f1, behaviorCnt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 模拟数据源[userId,behavior,product]</span></span><br><span class="line">        DataStreamSource&lt;Tuple3&lt;Long, String, String&gt;&gt; userBehaviors = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"iphone"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"cart"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"logi"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"fav"</span>, <span class="string">"oppo"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"onemore"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"fav"</span>, <span class="string">"iphone"</span>));</span><br><span class="line">        userBehaviors</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> UserBehaviorCnt())</span><br><span class="line">                .print();</span><br><span class="line">        env.execute(<span class="string">"MapStateExample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/MapStateExample.png" alt></p>
<h4 id="状态的生命周期管理-TTL"><a href="#状态的生命周期管理-TTL" class="headerlink" title="状态的生命周期管理(TTL)"></a>状态的生命周期管理(TTL)</h4><p>对于任何类型Keyed State都可以设定状态的生命周期（TTL）,即状态的存活时间，以确保能够在规定时间内及时地清理状态数据。如果配置了状态的TTL，那么当状态过期时，存储的状态会被清除。状态生命周期功能可以通过StateTtlConfig配置，然后将StateTtlConfig配置传入StateDescriptor中的enableTimeToLive方法中即可。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">                 <span class="comment">// 指定TTL时长为10S</span></span><br><span class="line">                .newBuilder(Time.seconds(<span class="number">10</span>))</span><br><span class="line">                 <span class="comment">// 只对创建和写入操作有效</span></span><br><span class="line">                .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">                 <span class="comment">// 不返回过期的数据</span></span><br><span class="line">                .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired) </span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.open(parameters);</span><br><span class="line">            MapStateDescriptor&lt;String, Integer&gt; userBehaviorMapStateDesc = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">                    <span class="string">"userBehavior"</span>,  <span class="comment">// 状态描述符的名称</span></span><br><span class="line">                    TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;String&gt;() &#123;&#125;),  <span class="comment">// MapState状态的key的数据类型</span></span><br><span class="line">                    TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Integer&gt;() &#123;&#125;)  <span class="comment">// MapState状态的value的数据类型</span></span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 设置stateTtlConfig</span></span><br><span class="line">            userBehaviorMapStateDesc.enableTimeToLive(ttlConfig);</span><br><span class="line">            behaviorCntState = getRuntimeContext().getMapState(userBehaviorMapStateDesc); <span class="comment">// 获取状态</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在StateTtlConfig创建时，newBuilder方法是必须要指定的，newBuilder中设定过期时间的参数。对于其他参数都是可选的或使用默认值。其中setUpdateType方法中传入的类型有三种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> UpdateType &#123;</span><br><span class="line">		<span class="comment">//禁用TTL,永远不会过期</span></span><br><span class="line">		Disabled,</span><br><span class="line">	    <span class="comment">// 创建和写入时更新TTL</span></span><br><span class="line">		OnCreateAndWrite,</span><br><span class="line">		<span class="comment">// 与OnCreateAndWrite类似，但是在读操作时也会更新TTL</span></span><br><span class="line">		OnReadAndWrite</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，过期的状态数据根据UpdateType参数进行配置，只有被写入或者读取的时间才会更新TTL，也就是说如果某个状态指标一直不被使用或者更新，则永远不会触发对该状态数据的清理操作，这种情况可能会导致系统中的状态数据越来越大。目前用户可以使用StateTtlConfig.cleanupFullSnapshot设定当触发State Snapshot的时候清理状态数据，但是改配置不适合用于RocksDB做增量Checkpointing的操作。</p>
<p>上面的StateTtlConfig创建时，可以指定setStateVisibility，用于状态的可见性配置，根据过期数据是否被清理来确定是否返回状态数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否返回过期的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StateVisibility &#123;</span><br><span class="line">	<span class="comment">//如果数据没有被清理，就可以返回</span></span><br><span class="line">	ReturnExpiredIfNotCleanedUp,</span><br><span class="line">	<span class="comment">//永远不返回过期的数据,默认值</span></span><br><span class="line">	NeverReturnExpired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a>Operator State</h3><p>Operator State的作用于是某个算子任务，这意味着所有在同一个并行任务之内的记录都能访问到相同的状态 。算子状态不能通过其他任务访问，无论该任务是相同的算子。如下图所示。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/operatorstate.png" alt></p>
<p>Operator State是一种non-keyed state，与并行的操作算子实例相关联，例如在Kafka Connector中，每个Kafka消费端算子实例都对应到Kafka的一个分区中，维护Topic分区和Offsets偏移量作为算子的Operator State。在Flink中可以实现ListCheckpointed<t extends serializable>接口或者CheckpointedFunction 接口来实现一个Operator State。</t></p>
<p>首先，我们先看一下这两个接口的具体实现，然后再给出这两种接口的具体使用案例。先看一下ListCheckpointed接口的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListCheckpointed</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取某个算子实例的当前状态，该状态包括该算子实例之前被调用时的所有结果</span></span><br><span class="line"><span class="comment">	 * 以列表的形式返回一个函数状态的快照</span></span><br><span class="line"><span class="comment">	 * Flink触发生成检查点时调用该方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> checkpointId checkpoint的ID,是一个唯一的、单调递增的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timestamp Job Manager触发checkpoint时的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>  返回一个operator state list,如果为null时,返回空list</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;T&gt; <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化函数状态时调用，可能是在作业启动时或者故障恢复时</span></span><br><span class="line"><span class="comment">	 * 根据提供的列表恢复函数状态</span></span><br><span class="line"><span class="comment">	 * 注意：当实现该方法时，需要在RichFunction#open()方法之前调用该方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> state 被恢复算子实例的state列表 ，可能为空</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(List&lt;T&gt; state)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Operator ListState时，在进行扩缩容时，重分布的策略(状态恢复的模式)如下图所示：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/operatorliststate%E6%89%A9%E7%BC%A9%E5%AE%B9.png" alt></p>
<p>上面的重分布策略为<strong>Even-split Redistribution</strong>，即每个算子实例中含有部分状态元素的List列表，整个状态数据是所有List列表的合集。当触发restore/redistribution动作时，通过将状态数据平均分配成与算子并行度相同数量的List列表，每个task实例中有一个List，其可以为空或者含有多个元素。</p>
<p>我们再来看一下CheckpointedFunction接口，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 会在生成检查点之前调用</span></span><br><span class="line"><span class="comment">	 * 该方法的目的是确保检查点开始之前所有状态对象都已经更新完毕</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context 使用FunctionSnapshotContext作为参数</span></span><br><span class="line"><span class="comment">	 *                从FunctionSnapshotContext可以获取checkpoint的元数据信息，</span></span><br><span class="line"><span class="comment">	 *                比如checkpoint编号，JobManager在初始化checkpoint时的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在创建checkpointedFunction的并行实例时被调用，</span></span><br><span class="line"><span class="comment">	 * 在应用启动或者故障重启时触发该方法的调用</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context 传入FunctionInitializationContext对象，</span></span><br><span class="line"><span class="comment">	 *                   可以使用该对象访问OperatorStateStore和 KeyedStateStore对象，</span></span><br><span class="line"><span class="comment">	 *                   这两个对象可以获取状态的句柄，即通过Flink runtime来注册函数状态并返回state对象</span></span><br><span class="line"><span class="comment">	 *                   比如：ValueState、ListState等</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckpointedFunction接口是用于指定有状态函数的最底层的接口，该接口提供了用于注册和维护keyed state 与operator state的hook(即可以同时使用keyed state 和operator state)，另外也是唯一支持使用list union state。关于Union List State,使用的是Flink为Operator state提供的另一种重分布的策略：<strong>Union Redistribution</strong>，即每个算子实例中含有所有状态元素的List列表，当触发restore/redistribution动作时，每个算子都能够获取到完整的状态元素列表。具体如下图所示：</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/operatorunionlist.png" alt></p>
<h4 id="ListCheckpointed"><a href="#ListCheckpointed" class="headerlink" title="ListCheckpointed"></a>ListCheckpointed</h4><p>ListCheckpointed接口和CheckpointedFunction接口相比在灵活性上相对弱一些，只能支持List类型的状态，并且在数据恢复的时候仅支持<strong>even-redistribution</strong>策略。该接口不像Flink提供的Keyed State(比如Value State、ListState)那样直接在状态后端(state backend)注册，需要将operator state实现为成员变量，然后通过接口提供的回调函数与状态后端进行交互。使用代码案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListCheckpointedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBehaviorCnt</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">ListCheckpointed</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long userBuyBehaviorCnt = <span class="number">0L</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Tuple3&lt;Long, String, String&gt; value, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value.f1.equals(<span class="string">"buy"</span>))&#123;</span><br><span class="line">                userBuyBehaviorCnt ++;</span><br><span class="line">                out.collect(Tuple2.of(<span class="string">"buy"</span>,userBuyBehaviorCnt));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//返回单个元素的List集合，该集合元素是用户购买行为的数量</span></span><br><span class="line">            <span class="keyword">return</span> Collections.singletonList(userBuyBehaviorCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(List&lt;Long&gt; state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 在进行扩缩容之后，进行状态恢复，需要把其他subtask的状态加在一起</span></span><br><span class="line">            <span class="keyword">for</span> (Long cnt : state) &#123;</span><br><span class="line">                userBuyBehaviorCnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 模拟数据源[userId,behavior,product]</span></span><br><span class="line">        DataStreamSource&lt;Tuple3&lt;Long, String, String&gt;&gt; userBehaviors = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"iphone"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"cart"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"logi"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"fav"</span>, <span class="string">"oppo"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"onemore"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"fav"</span>, <span class="string">"iphone"</span>));</span><br><span class="line"></span><br><span class="line">        userBehaviors</span><br><span class="line">                .flatMap(<span class="keyword">new</span> UserBehaviorCnt())</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"ListCheckpointedExample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckpointedFunction"><a href="#CheckpointedFunction" class="headerlink" title="CheckpointedFunction"></a>CheckpointedFunction</h4><p>CheckpointedFunction接口提供了更加丰富的操作，比如支持Union list state，可以访问keyedState，关于重分布策略，如果使用Even-split Redistribution策略，则通过context. getListState(descriptor)获取Operator State；如果使用UnionRedistribution策略，则通过context. getUnionList State(descriptor)来获取。使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckpointFunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBehaviorCnt</span> <span class="keyword">implements</span> <span class="title">CheckpointedFunction</span>, <span class="title">FlatMapFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个operator实例的用户行为数量的本地变量</span></span><br><span class="line">        <span class="keyword">private</span> Long opUserBehaviorCnt = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// 每个key的state,存储key对应的相关状态</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Long&gt; keyedCntState;</span><br><span class="line">        <span class="comment">// 定义operator state，存储算子的状态</span></span><br><span class="line">        <span class="keyword">private</span> ListState&lt;Long&gt; opCntState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Tuple3&lt;Long, String, String&gt; value, Collector&lt;Tuple3&lt;Long, Long, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value.f1.equals(<span class="string">"buy"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 更新算子状态本地变量值</span></span><br><span class="line">                opUserBehaviorCnt += <span class="number">1</span>;</span><br><span class="line">                Long keyedCount = keyedCntState.value();</span><br><span class="line">                <span class="comment">// 更新keyedstate的状态 ,判断状态是否为null，否则空指针异常</span></span><br><span class="line">                keyedCntState.update(keyedCount == <span class="keyword">null</span> ? <span class="number">1L</span> : keyedCount + <span class="number">1</span> );</span><br><span class="line">                <span class="comment">// 结果输出</span></span><br><span class="line">                out.collect(Tuple3.of(value.f0, keyedCntState.value(), opUserBehaviorCnt));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 使用opUserBehaviorCnt本地变量更新operator state</span></span><br><span class="line">            opCntState.clear();</span><br><span class="line">            opCntState.add(opUserBehaviorCnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过KeyedStateStore,定义keyedState的StateDescriptor描述符</span></span><br><span class="line">            ValueStateDescriptor valueStateDescriptor = <span class="keyword">new</span> ValueStateDescriptor(<span class="string">"keyedCnt"</span>, TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Long&gt;() &#123;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过OperatorStateStore,定义OperatorState的StateDescriptor描述符</span></span><br><span class="line">            ListStateDescriptor opStateDescriptor = <span class="keyword">new</span> ListStateDescriptor(<span class="string">"opCnt"</span>, TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Long&gt;() &#123;</span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="comment">// 初始化keyed state状态值</span></span><br><span class="line">            keyedCntState = context.getKeyedStateStore().getState(valueStateDescriptor);</span><br><span class="line">            <span class="comment">// 初始化operator state状态</span></span><br><span class="line">            opCntState = context.getOperatorStateStore().getListState(opStateDescriptor);</span><br><span class="line">            <span class="comment">// 初始化本地变量operator state</span></span><br><span class="line">            <span class="keyword">for</span> (Long state : opCntState.get()) &#123;</span><br><span class="line">                opUserBehaviorCnt += state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 模拟数据源[userId,behavior,product]</span></span><br><span class="line">        DataStreamSource&lt;Tuple3&lt;Long, String, String&gt;&gt; userBehaviors = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"iphone"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"cart"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"buy"</span>, <span class="string">"logi"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="string">"fav"</span>, <span class="string">"oppo"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"huawei"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"buy"</span>, <span class="string">"onemore"</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="string">"fav"</span>, <span class="string">"iphone"</span>));</span><br><span class="line"></span><br><span class="line">        userBehaviors</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> UserBehaviorCnt())</span><br><span class="line">                .print();</span><br><span class="line">        env.execute(<span class="string">"CheckpointFunctionExample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是状态后端"><a href="#什么是状态后端" class="headerlink" title="什么是状态后端"></a>什么是状态后端</h2><p>上面使用的状态都需要存储到状态后端(StateBackend)，然后在checkpoint触发时，将状态持久化到外部存储系统。Flink提供了三种类型的状态后端，分别是基于内存的状态后端(<strong>MemoryStateBackend</strong>、基于文件系统的状态后端(<strong>FsStateBackend</strong>)以及基于RockDB作为存储介质的<strong>RocksDB StateBackend</strong>。这三种类型的StateBackend都能够有效地存储Flink流式计算过程中产生的状态数据，在默认情况下Flink使用的是MemoryStateBackend，区别见下表。下面分别对每种状态后端的特点进行说明。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/F:%5Cnpm%5Cmywebsite%5Csource_posts%5CFlink%E5%86%85%E9%83%A8Exactly-Once%E4%B8%89%E6%9D%BF%E6%96%A7-%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E4%B8%8E%E6%A3%80%E6%9F%A5%E7%82%B9%5Cstatebackend.png" alt></p>
<h3 id="状态后端的类别"><a href="#状态后端的类别" class="headerlink" title="状态后端的类别"></a>状态后端的类别</h3><h4 id="MemoryStateBackend"><a href="#MemoryStateBackend" class="headerlink" title="MemoryStateBackend"></a>MemoryStateBackend</h4><p>MemoryStateBackend将状态数据全部存储在JVM堆内存中，包括用户在使用DataStream API中创建的Key/Value State，窗口中缓存的状态数据，以及触发器等数据。MemoryStateBackend具有非常快速和高效的特点，但也具有非常多的限制，最主要的就是内存的容量限制，一旦存储的状态数据过多就会导致系统内存溢出等问题，从而影响整个应用的正常运行。同时如果机器出现问题，整个主机内存中的状态数据都会丢失，进而无法恢复任务中的状态数据。因此从数据安全的角度建议用户尽可能地避免在生产环境中使用MemoryStateBackend。Flink将MemoryStateBackend作为默认状态后端。</p>
<p>MemoryStateBackend比较适合用于测试环境中，并用于本地调试和验证，不建议在生产环境中使用。但如果应用状态数据量不是很大，例如使用了大量的非状态计算算子，也可以在生产环境中使MemoryStateBackend.</p>
<h4 id="FsStateBackend"><a href="#FsStateBackend" class="headerlink" title="FsStateBackend"></a>FsStateBackend</h4><p>FsStateBackend是基于文件系统的一种状态后端，这里的文件系统可以是本地文件系统，也可以是HDFS分布式文件系统。创建FsStateBackend的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FsStateBackend(Path checkpointDataUri, <span class="keyword">boolean</span> asynchronousSnapshots)</span><br></pre></td></tr></table></figure>

<p>其中path如果为本地路径，其格式为“file:///data/flink/checkpoints”，如果path为HDFS路径，其格式为“hdfs://nameservice/flink/checkpoints”。FsStateBackend中第二个Boolean类型的参数指定是否以同步的方式进行状态数据记录，默认采用异步的方式将状态数据同步到文件系统中，异步方式能够尽可能避免在Checkpoint的过程中影响流式计算任务。如果用户想采用同步的方式进行状态数据的检查点数据，则将第二个参数指定为True即可。</p>
<p>相比于MemoryStateBackend, FsStateBackend更适合任务状态非常大的情况，例如应用中含有时间范围非常长的窗口计算，或Key/value State状态数据量非常大的场景，这时系统内存不足以支撑状态数据的存储。同时FsStateBackend最大的好处是相对比较稳定，在checkpoint时，将状态持久化到像HDFS分布式文件系统中，能最大程度保证状态数据的安全性。</p>
<h4 id="RocksDBStateBackend"><a href="#RocksDBStateBackend" class="headerlink" title="RocksDBStateBackend"></a>RocksDBStateBackend</h4><p>与前面的状态后端不同，RocksDBStateBackend需要单独引入相关的依赖包。RocksDB 是一个 key/value 的内存存储系统，类似于HBase，是一种内存磁盘混合的 LSM DB。当写数据时会先写进write buffer(类似于HBase的memstore)，然后在flush到磁盘文件，当读取数据时会现在block cache(类似于HBase的block cache)，所以速度会很快。</p>
<p>RocksDBStateBackend在性能上要比FsStateBackend高一些，主要是因为借助于RocksDB存储了最新热数据，然后通过异步的方式再同步到文件系统中，但RocksDBStateBackend和MemoryStateBackend相比性能就会较弱一些。</p>
<p>需要注意 RocksDB 不支持同步的 Checkpoint，构造方法中没有同步快照这个选项。不过 RocksDB 支持增量的 Checkpoint，也是目前唯一增量 Checkpoint 的 Backend，意味着并不需要把所有 sst 文件上传到 Checkpoint 目录，仅需要上传新生成的 sst 文件即可。它的 Checkpoint 存储在外部文件系统（本地或HDFS），其容量限制只要单个 TaskManager 上 State 总量不超过它的内存+磁盘，单 Key最大 2G，总大小不超过配置的文件系统容量即可。对于超大状态的作业，例如天级窗口聚合等场景下可以使会用该状态后端。</p>
<h3 id="配置状态后端"><a href="#配置状态后端" class="headerlink" title="配置状态后端"></a>配置状态后端</h3><p>Flink默认使用的状态后端是MemoryStateBackend，所以不需要显示配置。对于其他的状态后端，都需要进行显性配置。在Flink中包含了两种级别的StateBackend配置：一种是在程序中进行配置，该配置只对当前应用有效；另外一种是通过 <code>flink-conf.yaml</code>进行全局配置，一旦配置就会对整个Flink集群上的所有应用有效。</p>
<ul>
<li>应用级别配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> FsStateBackend(<span class="string">"hdfs://namenode:40010/flink/checkpoints"</span>));</span><br></pre></td></tr></table></figure>

<p>如果使用RocksDBStateBackend则需要单独引入rockdb依赖库,如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-statebackend-rocksdb_2.11&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.10.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方式与FsStateBackend类似，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> RocksDBStateBackend(<span class="string">"hdfs://namenode:40010/flink/checkpoints"</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>集群级别配置</li>
</ul>
<p>具体的配置项在flink-conf.yaml文件中，如下代码所示，参数state.backend指明StateBackend类型，state.checkpoints.dir配置具体的状态存储路径，代码中使用filesystem作为StateBackend，然后指定相应的HDFS文件路径作为state的checkpoint文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用filesystem存储</span></span><br><span class="line">state.backend: filesystem</span><br><span class="line"><span class="comment"># checkpoint存储路径</span></span><br><span class="line">state.checkpoints.dir: hdfs://namenode:40010/flink/checkpoints</span><br></pre></td></tr></table></figure>

<p>如果想用RocksDBStateBackend配置集群级别的状态后端，可以使用下面的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 操作RocksDBStateBackend的线程数量，默认值为1</span></span><br><span class="line">state.backend.rocksdb.checkpoint.transfer.thread.num: 1</span><br><span class="line"><span class="comment"># 指定RocksDB存储状态数据的本地文件路径</span></span><br><span class="line">state.backend.rocksdb.localdir: /var/rockdb/checkpoints</span><br><span class="line"><span class="comment"># 用于指定定时器服务的工厂类实现类，默认为“HEAP”，也可以指定为“RocksDB”</span></span><br><span class="line">state.backend.rocksdb.timer-service.factory: HEAP</span><br></pre></td></tr></table></figure>

<h2 id="什么是Checkpoint-检查点"><a href="#什么是Checkpoint-检查点" class="headerlink" title="什么是Checkpoint(检查点)"></a>什么是Checkpoint(检查点)</h2><p>上面讲解了Flink的状态以及状态后端，状态是存储在状态后端。为了保证state容错，Flink提供了处理故障的措施，这种措施称之为checkpoint(一致性检查点)。checkpoint是Flink实现容错的核心功能，主要是周期性地触发checkpoint，将state生成快照持久化到外部存储系统(比如HDFS)。这样一来，如果Flink程序出现故障，那么就可以从上一次checkpoint中进行状态恢复，从而提供容错保障。另外，通过checkpoint机制，Flink可以实现Exactly-once语义(Flink内部的Exactly-once,关于端到端的exactly_once,Flink是通过两阶段提交协议实现的)。下面将会详细分析Flink的checkpoint机制。</p>
<h3 id="检查点的生成"><a href="#检查点的生成" class="headerlink" title="检查点的生成"></a>检查点的生成</h3><p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/checkpoint_%E6%A6%82%E8%A7%88.png" alt></p>
<p>如上图，输入流是用户行为数据，包括购买(buy)和加入购物车(cart)两种，每种行为数据都有一个偏移量，统计每种行为的个数。</p>
<p>第一步：JobManager checkpoint coordinator 触发checkpoint。</p>
<p>第二步：假设当消费到[cart，3]这条数据时，触发了checkpoint。那么此时数据源会把消费的偏移量3写入持久化存储。</p>
<p>第三步：当写入结束后，source会将state handle(状态存储路径)反馈给JobManager的checkpoint coordinator。</p>
<p>第四步：接着算子count buy与count cart也会进行同样的步骤</p>
<p>第五步：等所有的算子都完成了上述步骤之后，即当 Checkpoint coordinator 收集齐所有 task 的 state handle，就认为这一次的 Checkpoint 全局完成了，向持久化存储中再备份一个 Checkpoint meta 文件，那么整个checkpoint也就完成了，如果中间有一个不成功，那么本次checkpoin就宣告失败。</p>
<h3 id="检查点的恢复"><a href="#检查点的恢复" class="headerlink" title="检查点的恢复"></a>检查点的恢复</h3><p>通过上面的分析，或许你已经对Flink的checkpoint有了初步的认识。那么接下来，我们看一下是如何从检查点恢复的。</p>
<ul>
<li>任务失败</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E4%BD%9C%E4%B8%9A%E5%A4%B1%E8%B4%A5.png" alt></p>
<ul>
<li>重启作业</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/1%E9%87%8D%E5%90%AF%E4%BD%9C%E4%B8%9A.png" alt></p>
<ul>
<li>恢复检查点</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/2%E6%A3%80%E6%9F%A5%E7%82%B9%E6%81%A2%E5%A4%8D.png" alt></p>
<ul>
<li>继续处理数据</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C.png" alt></p>
<p>上述过程具体总结如下：</p>
<ul>
<li>第一步：重启作业</li>
<li>第二步：从上一次检查点恢复状态数据</li>
<li>第三步：继续处理新的数据</li>
</ul>
<h3 id="Flink内部Exactly-Once实现"><a href="#Flink内部Exactly-Once实现" class="headerlink" title="Flink内部Exactly-Once实现"></a>Flink内部Exactly-Once实现</h3><p>Flink提供了精确一次的处理语义，精确一次的处理语义可以理解为：数据可能会重复计算，但是结果状态只有一个。Flink通过Checkpoint机制实现了精确一次的处理语义，Flink在触发Checkpoint时会向Source端插入checkpoint barrier，checkpoint barriers是从source端插入的，并且会向下游算子进行传递。checkpoint barriers携带一个checkpoint ID，用于标识属于哪一个checkpoint，checkpoint barriers将流逻辑是哪个分为了两部分。对于双流的情况，通过barrier对齐的方式实现精确一次的处理语义。</p>
<p>关于什么是checkpoint barrier，可以看一下CheckpointBarrier类的源码描述，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checkpoint barriers用来在数据流中实现checkpoint对齐的.</span></span><br><span class="line"><span class="comment"> * Checkpoint barrier由JobManager的checkpoint coordinator插入到Source中,</span></span><br><span class="line"><span class="comment"> * Source会把barrier广播发送到下游算子,当一个算子接收到了其中一个输入流的Checkpoint barrier时,</span></span><br><span class="line"><span class="comment"> * 它就会知道已经处理完了本次checkpoint与上次checkpoint之间的数据.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一旦某个算子接收到了所有输入流的checkpoint barrier时，</span></span><br><span class="line"><span class="comment"> * 意味着该算子的已经处理完了截止到当前checkpoint的数据，</span></span><br><span class="line"><span class="comment"> * 可以触发checkpoint，并将barrier向下游传递</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 根据用户选择的处理语义，在checkpoint完成之前会缓存后一次checkpoint的数据，</span></span><br><span class="line"><span class="comment"> * 直到本次checkpoint完成(exactly once)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * checkpoint barrier的id是严格单调递增的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckpointBarrier</span> <span class="keyword">extends</span> <span class="title">RuntimeEvent</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出checkpoint barrier主要功能是实现checkpoint对齐的，从而可以实现Exactly-Once处理语义。</p>
<p>下面将会对checkpoint过程进行分解，具体如下：</p>
<p>图1，包括两个流，每个任务都会消费一条用户行为数据(包括购买(buy)和加购(cart))，数字代表该数据的偏移量，count buy任务统计购买行为的个数，coun cart统计加购行为的个数。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%811.png" alt></p>
<p>图2，触发checkpoint，JobManager会向每个数据源发送一个新的checkpoint编号，以此来启动检查点生成流程。</p>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%812.png" alt></p>
<ul>
<li>图3，当Source任务收到消息后，会停止发出数据，然后利用状态后端触发生成本地状态检查点，并把该checkpoint barrier以及checkpoint id广播至所有传出的数据流分区。状态后端会在checkpoint完成之后通知任务，随后任务会向Job Manager发送确认消息。在将checkpoint barrier发出之后，Source任务恢复正常工作。</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%813.png" alt></p>
<ul>
<li>图4，Source任务发出的checkpoint barrier会发送到与之相连的下游算子任务，当任务收到一个新的checkpoint barrier时，会继续等待其他输入分区的checkpoint barrier到来，这个过程称之为<strong>barrier 对齐</strong>，checkpoint barrier到来之前会把到来的数据线缓存起来。</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%814.png" alt></p>
<ul>
<li>图5，任务收齐了全部输入分区的checkpoint barrier之后，会通知状态后端开始生成checkpoint，同时会把checkpoint barrier广播至下游算子。</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%815.png" alt></p>
<ul>
<li>图6，任务在发出checkpoint barrier之后，开始处理因barrier对齐产生的缓存数据，在缓存的数据处理完之后，就会继续处理输入流数据。</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%816.png" alt></p>
<ul>
<li>图7，最终checkpoint barrier会被传送到sink端，sink任务接收到checkpoint barrier之后，会向其他算子任务一样，将自身的状态写入checkpoint，之后向Job Manager发送确认消息。Job Manager接收到所有任务返回的确认消息之后，就会将此次检查点标记为完成。</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/%E7%8A%B6%E6%80%817.png" alt></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint的时间间隔，如果状态比较大，可以适当调大该值</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 配置处理语义，默认是exactly-once</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 两个checkpoint之间的最小时间间隔，防止因checkpoint时间过长，导致checkpoint积压</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// checkpoint执行的上限时间，如果超过该阈值，则会中断checkpoint</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 最大并行执行的检查点数量，默认为1，可以指定多个，从而同时出发多个checkpoint，提升效率</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设定周期性外部检查点，将状态数据持久化到外部系统中，</span></span><br><span class="line"><span class="comment">// 使用该方式不会在任务正常停止的过程中清理掉检查点数据</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">// allow job recovery fallback to checkpoint when there is a more recent savepoint</span></span><br><span class="line">env.getCheckpointConfig().setPreferCheckpointForRecovery(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先从Flink的状态入手，通过Spark的WordCount和Flink的Work Count进行说明什么是状态。接着对状态的分类以及状态的使用进行了详细说明。然后对Flink提供的三种状态后端进行讨论，并给出了状态后端的使用说明。最后，以图解加文字的形式详细解释了Flink的checkpoint机制，并给出了使用Checkpoint时的程序配置。</p>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/" target="_blank">透过窗口看无限数据流——Flink的Window全面解析</a></li><li><a href="https://jiamaoxiang.top/2020/04/30/Flink-DataStream-API-中的多面手——Process-Function详解/" target="_blank">Flink DataStream API 中的多面手——Process Function详解</a></li><li><a href="https://jiamaoxiang.top/2020/04/17/Flink基于时间与窗口的算子/" target="_blank">Flink的时间与watermarks详解</a></li><li><a href="https://jiamaoxiang.top/2020/04/12/Flink-DataStream-API编程指南/" target="_blank">Flink DataStream API编程指南</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/">https://jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/" data-id="ck9wbj9n2002si07qiet40tei" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJUlEQVR42u3a0W7bQAwEwPz/T6dAn1q0tndJBbDOo6dAkU+cMxCG5H19xdf37+vR/T9/+++d58/n73302Xy1+sLGxsa+Cfv76fXo9ckKeejPqclG5xZsbGzsU9lXvb598vkK+Z3cgo2Njf3J7LwMSGBJ6LMEho2NjY2dhJIXMJviJI8BGxsbGzsHtInkeXPnRetn/a4LemnY2NjYb8+eDVzf8+cfnG9jY2NjvyX7e3TtV0vCzdNnHT82Njb2QezNgcgN7KrxQF4afV11DhQbGxv7Ldn5mLYFtNuak9pxcrQF2NjY2Ddn54+2RUJ76CdHXpDAsLGxsW/OTkqF9jDNPuUkEc4i+auXho2NjX0Eu/3T39Y0s+M4s9XqUgQbGxv7OHYb0GY8fFW5stpcbGxs7CPYbSs/GdC21J/g1d8zNjY29s3Z+bg0b+5sDuK0n03eXkxCsLGxsW/FnjHa0qJ9SzJOnpVG2NjY2Oex96PWNrXkyTJPVO3WYGNjY5/EzkNvi4281JkVGO0QYviNYWNjY9+E/byt095pGzptydGuVvTVsLGxsW/LzntObcLIj+bMWlGbDcLGxsY+g91S8yZRW8Bc1bqKNhobGxv7w9h5KydvHrXHg2atJWxsbOxPY88AszFt/kyS8NoIsbGxsU9lt239Wcu+LRvyoiUZOUf7io2NjX0rdhtcvmiCuWo8vGlFYWNjY9+dnaeufVNp1tbfDJgffhYbGxv7aHZ7J9+yltqCi0YVNjY29kHs9t/6eqQ62qxNAVOMkLGxsbEPYretmVnxkFyzjUtI2NjY2J/GblNFmzbabWqT6OobxsbGxr4te0adHZ2ZtZBm+BfFDzY2NvZx7K/FdW3QM1iSJrGxsbFPYs+aPtcOa9sU2KbV/6yGjY2NfRC7TU4XLBSMZjeYZMyAjY2NfR47b83nQ9w8oM1BnHyDXnTRsLGxsY9gzxr9mwy5SYSb1hI2NjY29mzUOjuUk8eZf0nY2NjYn8zeHKactYRelBOLGLCxsbHPY7epJT9es2kzJasNj3tiY2NjH8SetWZmA4O8MbRfM/8UNjY29m3ZvwCPgW3xyfoiOgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2020/04/30/Flink-DataStream-API-中的多面手——Process-Function详解/">Flink DataStream API 中的多面手——Process Function详解</a><a class="next" href="/2020/04/17/Flink基于时间与窗口的算子/">Flink的时间与watermarks详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是状态"><span class="toc-number">1.</span> <span class="toc-text">什么是状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引子"><span class="toc-number">1.1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态的类别"><span class="toc-number">1.2.</span> <span class="toc-text">状态的类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#managed-state-amp-raw-state区别"><span class="toc-number">1.2.1.</span> <span class="toc-text">managed state &amp; raw state区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Keyed-State-amp-Operator-State"><span class="toc-number">1.2.2.</span> <span class="toc-text">Keyed State &amp; Operator State</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyed-State"><span class="toc-number">1.3.</span> <span class="toc-text">Keyed State</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyed-State使用案例"><span class="toc-number">1.3.1.</span> <span class="toc-text">keyed State使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态的生命周期管理-TTL"><span class="toc-number">1.3.2.</span> <span class="toc-text">状态的生命周期管理(TTL)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operator-State"><span class="toc-number">1.4.</span> <span class="toc-text">Operator State</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ListCheckpointed"><span class="toc-number">1.4.1.</span> <span class="toc-text">ListCheckpointed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CheckpointedFunction"><span class="toc-number">1.4.2.</span> <span class="toc-text">CheckpointedFunction</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是状态后端"><span class="toc-number">2.</span> <span class="toc-text">什么是状态后端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#状态后端的类别"><span class="toc-number">2.1.</span> <span class="toc-text">状态后端的类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MemoryStateBackend"><span class="toc-number">2.1.1.</span> <span class="toc-text">MemoryStateBackend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FsStateBackend"><span class="toc-number">2.1.2.</span> <span class="toc-text">FsStateBackend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RocksDBStateBackend"><span class="toc-number">2.1.3.</span> <span class="toc-text">RocksDBStateBackend</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置状态后端"><span class="toc-number">2.2.</span> <span class="toc-text">配置状态后端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Checkpoint-检查点"><span class="toc-number">3.</span> <span class="toc-text">什么是Checkpoint(检查点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检查点的生成"><span class="toc-number">3.1.</span> <span class="toc-text">检查点的生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查点的恢复"><span class="toc-number">3.2.</span> <span class="toc-text">检查点的恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink内部Exactly-Once实现"><span class="toc-number">3.3.</span> <span class="toc-text">Flink内部Exactly-Once实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用案例"><span class="toc-number">3.4.</span> <span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>