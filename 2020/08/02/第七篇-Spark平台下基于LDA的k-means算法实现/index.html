<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>第七篇|Spark平台下基于LDA的k-means算法实现 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第七篇|Spark平台下基于LDA的k-means算法实现</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第七篇|Spark平台下基于LDA的k-means算法实现</h1><div class="post-meta">Aug 2, 2020<span> | </span><span class="category"><a href="/categories/Spark/">Spark</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 18</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><a id="more"></a>

<p>本文主要在Spark平台下实现一个机器学习应用，该应用主要涉及LDA主题模型以及K-means聚类。通过本文你可以了解到：</p>
<ul>
<li>文本挖掘的基本流程</li>
<li>LDA主题模型算法</li>
<li>K-means算法</li>
<li>Spark平台下LDA主题模型实现</li>
<li>Spark平台下基于LDA的K-means算法实现</li>
</ul>
<h2 id="1-文本挖掘模块设计"><a href="#1-文本挖掘模块设计" class="headerlink" title="1.文本挖掘模块设计"></a>1.文本挖掘模块设计</h2><h3 id="1-1文本挖掘流程"><a href="#1-1文本挖掘流程" class="headerlink" title="1.1文本挖掘流程"></a>1.1文本挖掘流程</h3><p>文本分析是机器学习中的一个很宽泛的领域，并且在情感分析、聊天机器人、垃圾邮件检测、推荐系统以及自然语言处理等方面得到了广泛应用。</p>
<p>文本聚类是信息检索领域的一个重要概念，在文本挖掘领域有着广泛的应用。文本聚类能够自动地将文本数据集划分为不同的类簇，从而更好地组织文本信息，可以实现高效的知识导航与浏览。</p>
<p>本文选择主题模型LDA(Latent Dirichlet Allocation)算法对文档进行分类处理，选择在Spark平台上通过Spark MLlib实现LDA算法，其中Spark Mllib是Spark提供的机器学习库，该库提供了常用的机器学习算法。其基本设计思路如下图所示：</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B.png" alt></p>
<h3 id="1-2文本挖掘流程分析"><a href="#1-2文本挖掘流程分析" class="headerlink" title="1.2文本挖掘流程分析"></a>1.2文本挖掘流程分析</h3><p>首先是数据源部分，主要的数据包括文档数据和互联网爬虫数据。然后是数据抽取部分，将已经收集好的数据通过同步工具上传至分布式文件系统HDFS，作为模型训练的数据源。其次是数据探索与预处理部分，该部分主要是对原始数据集进行预处理，包括分词、停用词过滤、特征向量提取等。再次是模型训练部分，主要包括训练与测试，从而得到一个模型。最后是模型评估，对学得模型进行评估之后，进行线上部署。</p>
<h2 id="2-文本挖掘模块算法研究"><a href="#2-文本挖掘模块算法研究" class="headerlink" title="2.文本挖掘模块算法研究"></a>2.文本挖掘模块算法研究</h2><h3 id="2-1LDA主题模型算法"><a href="#2-1LDA主题模型算法" class="headerlink" title="2.1LDA主题模型算法"></a>2.1LDA主题模型算法</h3><p>LDA（Latent Dirichlet allocation）由David M. Blei，Andrew Y. Ng，Michael I. Jordan于2003年提出的基于概率模型的主题模型算法，即隐含狄利克雷分布，它可以将文档集中每篇文档的主题以概率分布的形式给出，将文本向量投射到更容易分析处理的主题空间当中，去除文本中存在的噪声，是一种常用的文本分析技术，可以用来识别大规模文档集或语料库中潜在的主题信息，通常被用来对大规模文档数据进行建模。通过主题模型和设定的主题数，可以训练出文档集合中不同的主题所占的比例以及每个主题下的关键词语出现的概率。从文档集合中学习得到主题分布和主题比例，可以进一步在数据挖掘任务中使用。如果生成一篇文档，则其中每个词出现的概率都可以通过下述公式来计算。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E5%9B%BE1.png" alt></p>
<p>LDA借用词袋的思想，以某一概率选取某个主题，再以某一概率选出主题中的每个单词，通过不断重复该步骤产生文档中的所有语词。该方法对词汇进行了模糊聚类，聚集到一类的词可以间接地表示一个隐含的主题。LDA对文本信息进行了挖掘，能用来衡量不同文档之间的潜在关系，也能通过某一类词来表达文档中隐藏的主题。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/LDA%E5%9B%BE%E6%A8%A1%E5%9E%8B.png" alt></p>
<h3 id="2-2K均值算法"><a href="#2-2K均值算法" class="headerlink" title="2.2K均值算法"></a>2.2K均值算法</h3><p>聚类(Clustering)是一种将数据集划分为若干组或类的方法。通过聚类过程将一群抽象的对象分为若干组，每一组由相似的对象构成，称之为一个类别。与分类不同(将数据按照事先定义好的分类标准进行划分)，聚类是一种无监督学习(unsupervised learning)，训练数据集的标签信息是未知的，目标是通过对无标记训练样本按照特定的测度的形似性程度进行聚合，为进一步数据分析提供基础。</p>
<p>K均值(k-means)算法的基本思想是初始随机给定K 个簇中心，即从n个数据对象中选择k个任意对象作为初始的簇中心，按照最邻近原则把待分类样本点分到各个簇。然后按平均法重新计算各个簇的中心(该类别中的所有数据对象的均值)，从而确定新的簇心。一直迭代，直到簇心的移动距离小于某个给定的值。</p>
<p>K均值算法采用了贪心策略，通过迭代优化来近似求解上式E值，算法流程如下图所示</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/Kmeans.png" alt> </p>
<h3 id="2-3文本挖掘算法优化"><a href="#2-3文本挖掘算法优化" class="headerlink" title="2.3文本挖掘算法优化"></a>2.3文本挖掘算法优化</h3><p>LDA主题模型算法应用于文档聚类，计算得出的主题可以看做是文档的聚类中心，利用主题模型进行文档聚类，可以有效地组织文档数据集。同时，由于LDA主题模型可以计算出每篇文档在不同主题下的概率分布，因此可以将此主题的概率分布作为文档的特征向量，从而将高维的文档向量投影到低维的特征空间中。</p>
<p>计算文本之间的距离是传统的K-means算法在进行文本聚类时的关键步骤，而文本通常是非结构化数据，构建的文本向量具有稀疏性和维度高的特点，同时，构建文本特征向量并未考虑到文字之间的语义关系，因此可能会造成位于同一类簇的文本之间具有非相似性。</p>
<p>因此本文基于LDA主题模型改进K-means算法，首先通过LDA主题模型对文档数据集进行建模，挖掘出每篇文档的主题概率分布，既能够达到文档降维和去除噪声的效果，又能弥补通过关键词构建文档特征向量容易造成丢失信息的缺陷。最后每篇文档的主题概率分布作为K-means算法的输入数据集。 </p>
<h2 id="3-实验分析"><a href="#3-实验分析" class="headerlink" title="3.实验分析"></a>3.实验分析</h2><h3 id="3-1基于Spark的LDA主题模型算法实现"><a href="#3-1基于Spark的LDA主题模型算法实现" class="headerlink" title="3.1基于Spark的LDA主题模型算法实现"></a>3.1基于Spark的LDA主题模型算法实现</h3><h4 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p>选择Newsgroups数据集作为该实验的训练集和测试集。Newgroups是一个新闻数据集，该数据集包括大约20000篇新闻文档，总共分为6个大类别，每个大类别又分不同的小类别，小类别共计20个，如下表所示。该新闻数据集已经成为了学界和业界在机器学习的文本挖掘实验中常用的数据集，比如文本分类和文本聚类。</p>
<p>该数据集共包含7个文件，其中3个文件为训练数据(train.data、train.label、train.map)，共计11269篇，另外3个文件为测试数据(test.data、test.label、test.map)，共计7505篇，另外一个文件为词汇表(vocabulary.txt),其第i行表示编号为i的单词的名称。文件扩展名为.data的文件格式为[docIdx wordIdx count]，其中docIdx表示文档编号，wordIdx表示词语的编号，count表示该词语的词频统计。文件扩展名为.label的文件表示文档的主题分类，每行数据代表某篇文档的类别。文件扩展名为.map的文表示类别编号与类别名称的映射关系，其具体格式为[labelName labelId]。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E6%95%B0%E6%8D%AE%E9%9B%86%E7%B1%BB%E5%88%AB.png" alt></p>
<h4 id="原始数据集处理"><a href="#原始数据集处理" class="headerlink" title="原始数据集处理"></a>原始数据集处理</h4><p>原始的数据集格式为[docIdx wordIdx count]，例如[1,20,2]表示在编号为1的文档中，编号为20的词语的词频是2。LDA接受的参数格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[label,(vector_ size, [wiIdx,wjIdx,···wnIdx ],[tfi,tfj,···tfn])]</span><br></pre></td></tr></table></figure>

<p>上述格式的数据代表一个带有标签的稀疏向量，其中label表示文档编号，vector_ size表示向量的维度，wnIdx表示词n的索引编号，tfn表示词n的词频。需要将原始数据转换成上述的格式，具体步骤如下：</p>
<ul>
<li><strong>Step1：将原始数据集上传至HDFS</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kms@kms-1 ~]$ hdfs dfs -put /opt/modules/train_data/lda/train.data  /train/lda/</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Step2:初始化SparkSession并加载数据</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>           </span><br><span class="line">                       .builder           </span><br><span class="line">                       .appName(<span class="string">s"<span class="subst">$&#123;this.getClass.getSimpleName&#125;</span>"</span>)                                          .getOrCreate()         </span><br><span class="line"><span class="comment">//设置日志级别         </span></span><br><span class="line"><span class="type">Logger</span>.getLogger(<span class="string">"org.apache.spark"</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)         <span class="type">Logger</span>.getLogger(<span class="string">"org.apache.hadoop"</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>) </span><br><span class="line"><span class="comment">//加载原始数据集</span></span><br><span class="line"><span class="keyword">val</span> rowDS = spark.read.textFile(<span class="string">"/train/lda/train.data"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Step3:数据集矩阵变换处理</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建形如MatrixEntry(row_index, column_index, value)的MatrixEntry</span></span><br><span class="line"><span class="keyword">val</span> matrixEntry:<span class="type">RDD</span>[<span class="type">MatrixEntry</span>] = rowDS.rdd.map(_.split(<span class="string">" "</span>))</span><br><span class="line">                           .map(rowdata =&gt; <span class="type">MatrixEntry</span>(rowdata(<span class="number">0</span>).toLong,rowdata(<span class="number">1</span>).toLong,rowdata(<span class="number">2</span>).toDouble))</span><br><span class="line"><span class="comment">//创建稀疏矩阵</span></span><br><span class="line"><span class="keyword">val</span> sparseMatrix: <span class="type">CoordinateMatrix</span> = <span class="keyword">new</span>  <span class="type">CoordinateMatrix</span>(matrixEntry)</span><br><span class="line"><span class="comment">//创建LabeledPoint数据集</span></span><br><span class="line"><span class="keyword">val</span> labelPointData = sparseMatrix.toIndexedRowMatrix.rows.map(r =&gt; (r.index, r.vector.asML))</span><br><span class="line"><span class="keyword">val</span> corpusDF = spark.createDataFrame(labelPointData).toDF(<span class="string">"label"</span>,<span class="string">"features"</span>)</span><br><span class="line">corpusDF.saveAsTextFile(<span class="string">"/tarin/lda/labelPointData"</span>)</span><br></pre></td></tr></table></figure>

<p>处理之后的部分数据集如下所示，其中一行代表一篇文档的特征向量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[4551,(53976,[23,27,29,30,44,45,48,314,425,748,767,825,930,969,995,1345,7033,13872,16798,19139,26846,26847,27081,29607,30801,31200,31201,31202],[2.0,1.0,3.0,3.0,1.0,1.0,1.0,1.0,2.0,3.0,1.0,2.0,1.0,1.0,2.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0])]</span><br><span class="line">[2493,(53976,[80,133,754,3699,4066,5190,6138,7327,7361,10267,10344,10949,11390,11683,11759,16206,22708,22709],[1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,2.0,1.0,1.0,2.0,1.0,1.0,1.0,1.0,2.0,1.0])]</span><br></pre></td></tr></table></figure>

<h4 id="k折交叉验证确定训练参数"><a href="#k折交叉验证确定训练参数" class="headerlink" title="k折交叉验证确定训练参数"></a>k折交叉验证确定训练参数</h4><p>交叉验证法(cross validation)是将数据集D划分为k个大小相似的互斥子集的一种方法，其中每个子集都尽可能地保持数据分布的一致性，即从数据集D中通过分层采样的方式得到。然后，每次再用k-1个子集的并集作为训练集，剩下的那个子集作为测试集；通过这样的处理，可以得到k组训练集和测试集，进而可以进行k次训练和测试，最终返回的是这k个测试结果的均值。交叉验证法评估结果的稳定性和保真性在很大程度上依赖于k的取值，为突出这一点，通常把交叉验证法称为<code>k折交叉验证(k-fold cross validation)</code>。K通常取值为10，称之为10折交叉验证,下图给出了10折交叉验证的示意图。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81.png" alt></p>
<p>困惑度(perplexity)指标是LDA 模型的原作者Blei 等提出的一种反应模型泛化能力的指标, 在评价模型的优劣上具有一定的代表性和普遍性。所谓困惑度就是文档在划分主题时确定性的评判, 反映的是模型对新样本的适用性。其计算公式如下所示。</p>
<p>​                           <img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E5%9B%B0%E6%83%91%E5%BA%A6.png" alt></p>
<p>十折交叉验证处理过程如下所示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数据集分割为10份，每份占10%</span></span><br><span class="line">    <span class="keyword">val</span> splitData = labelPointData.randomSplit(<span class="type">Array</span>.fill(<span class="number">10</span>)(<span class="number">0.1</span>))</span><br><span class="line">   <span class="comment">//设定主题的个数为15-25</span></span><br><span class="line">    <span class="keyword">val</span> rangTopic = <span class="number">15</span> to <span class="number">25</span></span><br><span class="line">    rangTopic.foreach &#123; k =&gt;</span><br><span class="line">      <span class="keyword">var</span> perplexity = <span class="number">0.0</span></span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">//选择其中9份做训练集</span></span><br><span class="line">        <span class="keyword">val</span> trainIdx = (<span class="number">0</span> to <span class="number">9</span>).toArray.filter(_ != i)</span><br><span class="line">        <span class="keyword">var</span> trainData = spark.sparkContext.union(</span><br><span class="line">          splitData(trainIdx(<span class="number">0</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">1</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">2</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">3</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">4</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">5</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">6</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">7</span>)),</span><br><span class="line">          splitData(trainIdx(<span class="number">8</span>)))</span><br><span class="line">        <span class="comment">//创建DataFrame</span></span><br><span class="line">        <span class="keyword">val</span> trainDF = spark.createDataFrame(trainData).toDF(<span class="string">"label"</span>,<span class="string">"features"</span>)</span><br><span class="line">        <span class="keyword">val</span> testDF = spark.createDataFrame(splitData(i)).toDF(<span class="string">"label"</span>,<span class="string">"features"</span>)</span><br><span class="line">        <span class="comment">//训练主题个数为k时的模型</span></span><br><span class="line">        <span class="keyword">val</span> lda = <span class="keyword">new</span> <span class="type">LDA</span>().setK(k).setMaxIter(<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">val</span> ldaModel = lda.fit(trainDF)</span><br><span class="line">       perplexity = perplexity + ldaModel.logPerplexity(testDF)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> avePerplexity = perplexity / <span class="number">10</span></span><br><span class="line">      <span class="type">System</span>.out.println(<span class="string">"当主题个数为 "</span> + k + <span class="string">"时，"</span> + <span class="string">"交叉验证的平均困惑度为 "</span> + avePerplexity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过十折交叉验证，验证在不同主题下(取值15-25)训练模型的平均困惑度，测试发现在主题k=20时，困惑度的值最小。由于困惑度值越小, 表示该模型具有较好的泛化能力，所以选择k=20作为主题个数。</p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>将主题个数设置为20，迭代次数设置为50，使用上述数据集训练LDA模型，具体步骤如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//训练LDA模型</span></span><br><span class="line">      <span class="keyword">val</span> lda = <span class="keyword">new</span> <span class="type">LDA</span>().setK(<span class="number">20</span>).setMaxIter(<span class="number">50</span>)</span><br><span class="line">      <span class="keyword">val</span> model = lda.fit(corpusDF)</span><br><span class="line">      <span class="keyword">val</span> ll = model.logLikelihood(corpusDF)</span><br><span class="line">      <span class="keyword">val</span> lp = model.logPerplexity(corpusDF)</span><br><span class="line">      println(<span class="string">"当主题个数为20时对数似然为: "</span> + ll)</span><br><span class="line">      println(<span class="string">"当主题个数为20时困惑度为: "</span> + lp)</span><br><span class="line">      <span class="comment">//描述主题</span></span><br><span class="line">      <span class="keyword">val</span> topics = model.describeTopics(<span class="number">5</span>)</span><br><span class="line">      println(<span class="string">"The topics described by their top-weighted terms:"</span>)</span><br><span class="line">      topics.show(<span class="literal">false</span>)</span><br><span class="line">      topics.rdd.saveAsTextFile(<span class="string">"/tarin/lda/topics"</span>)</span><br><span class="line">      <span class="comment">// 测试结果</span></span><br><span class="line">    <span class="keyword">val</span> transformed = model.transform(corpusDF)</span><br><span class="line">transformed.select(<span class="string">"label"</span>,<span class="string">"topicDistribution"</span>).rdd.saveAsTextFile(<span class="string">"/tarin/lda /testtopic"</span>)</span><br></pre></td></tr></table></figure>

<p>通过训练得到LDA模型，其中训练数据的主题-单词概率分布如下表所示，选择权重排名在前5的单词，其中topic表示主题编号，termIndices表示词语编号组成的集合，termWeights表示词语编号对应的权重的集合。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E4%B8%BB%E9%A2%98%E5%8D%95%E8%AF%8D%E6%A6%82%E7%8E%87.png" alt></p>
<p>每个主题对应的单词列表如下表所示，其中topic表示主题，termIndices表示词语编号组成的集合,vocabulary表示词汇。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E8%AF%8D%E6%B1%87%E8%A1%A8.png" alt></p>
<p>该模型的文档-主题分布如下表所示，由于文档较多，这里仅列出部分文档，其中label表示文档编号，topicDistribution表示文档的主题分布。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E6%96%87%E6%A1%A3%E6%A0%87%E7%AD%BE.png" alt></p>
<p>通过上面的分析，得到了文本的主题分布。每篇文档将对应一个主题的特征空间，从而达到降维的目的。主题-单词单词概率分布描述了主题的特征空间，其中主题表示聚类中心。</p>
<p>结合词汇表与训练集，将其处理成[word,count]的形式，其中word表示单词，count表示该次出现的频次，具体的处理过程如下。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.apache.ml</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setMaster(<span class="string">"local"</span>)</span><br><span class="line">      .setAppName(<span class="string">"wordcount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rawRDD = sc.textFile(<span class="string">"e:///lda/train.data"</span>)</span><br><span class="line">    <span class="keyword">val</span> vocabulary = sc.textFile(<span class="string">"e:///lda/vocabulary.txt"</span>)</span><br><span class="line">    <span class="keyword">val</span> word_nums = rawRDD.map(_.split(<span class="string">" "</span>)).map(row =&gt; (row(<span class="number">1</span>).toLong, row(<span class="number">2</span>).toInt))</span><br><span class="line">    <span class="keyword">val</span> word_count = word_nums.reduceByKey(_ + _)</span><br><span class="line">    <span class="keyword">val</span> sort_wcnt = word_count.sortByKey(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">//处理词汇表</span></span><br><span class="line">    <span class="keyword">val</span> num_vocabulary = vocabulary.zipWithIndex().map(row =&gt; (row._2, row._1))</span><br><span class="line">    <span class="keyword">val</span> sort_combination = sort_wcnt.join(num_vocabulary)</span><br><span class="line">      .map(row =&gt; (row._2._1, row._2._2))</span><br><span class="line">      .sortByKey(<span class="literal">false</span>)</span><br><span class="line">      .map(row =&gt; (row._2, row._1))</span><br><span class="line">    sort_combination.saveAsTextFile(<span class="string">"e:///combination"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用R语言的wordcloud2包，进行可视化文档词云图展示，见下图</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E8%AF%8D%E4%BA%91%E5%9B%BE.png" alt></p>
<h3 id="3-2Spark平台下基于LDA的k-means算法实现"><a href="#3-2Spark平台下基于LDA的k-means算法实现" class="headerlink" title="3.2Spark平台下基于LDA的k-means算法实现"></a>3.2Spark平台下基于LDA的k-means算法实现</h3><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>将通过LDA主题模型计算的文档-主题分布作为k-means的输入，文档-主题分布的形式为[label, features，topicDistribution]，其中features代表文档的特征向量，每一行数据代表一篇文档。由于k-means接受的特征向量输入的形式为[label，features]，所以需要将原始的数据集schema转化为[label，features]的形式，即将topicDistribution列名转为features。处理步骤为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Val</span> trainDF =   transformed.select(<span class="string">"label"</span>,<span class="string">"topicDistribution"</span>).toDF(<span class="string">"label"</span>,   <span class="string">"features"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>Spark ML的K-means算法提供了如下的参数配置：</p>
<ul>
<li><p>setFeaturesCol(value: String)：设置输入的特征向量列，默认值为features</p>
</li>
<li><p>setK(value: Int)：设置类簇的个数 </p>
</li>
<li><p>setMaxIter(value: Int)：设置最大迭代次数</p>
</li>
<li><p>setPredictionCol(value: String)：设置输出列名称，默认为prediction</p>
</li>
<li><p>setSeed(value: Long)：设置随机数种子</p>
</li>
<li><p>setTol(value: Double)：设置收敛阈值</p>
</li>
</ul>
<p>设置最大迭代次数为200，随机数种子为123，类簇个数为2、4、6、8、10、12、14、16、18、20，其余选择默认值，分别观察评估指标的变化情况。具体代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> to <span class="number">20</span> by <span class="number">2</span>).toList.map &#123;k =&gt;</span><br><span class="line">      <span class="keyword">val</span> kmeans = <span class="keyword">new</span> <span class="type">KMeans</span>().setK(k).setSeed(<span class="number">123</span>).setMaxIter(<span class="number">200</span>)</span><br><span class="line">      <span class="keyword">val</span> kmeansModel = kmeans.fit(kMeansTrain)</span><br><span class="line">      <span class="comment">// 预测结果</span></span><br><span class="line">      <span class="keyword">val</span> predictions = kmeansModel.transform(kMeansTrain)</span><br><span class="line">      <span class="comment">//计算误差平方和</span></span><br><span class="line">      <span class="keyword">val</span> wssse = kmeansModel.computeCost(kMeansTrain)</span><br><span class="line">      println(<span class="string">s"Within set sum of squared errors = <span class="subst">$wssse</span>"</span>)</span><br><span class="line">      <span class="comment">// 计算轮廓系数</span></span><br><span class="line">      <span class="keyword">val</span> evaluator = <span class="keyword">new</span> <span class="type">ClusteringEvaluator</span>()</span><br><span class="line">      <span class="keyword">val</span> silhouette = evaluator.evaluate(predictions)</span><br><span class="line">      println(<span class="string">s"Silhouette with squared euclidean distance = <span class="subst">$silhouette</span>"</span>)</span><br><span class="line">      <span class="comment">//显示聚类结果</span></span><br><span class="line">      println(<span class="string">"Cluster Centers: "</span>)</span><br><span class="line">      kmeansModel.clusterCenters.foreach(println)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>经过训练，得到当K为6时聚类效果最好，此时的聚类结果如下表所示：</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E8%81%9A%E7%B1%BB%E7%BB%93%E6%9E%9C.png" alt></p>
<h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><ul>
<li>轮廓系数</li>
</ul>
<p>轮廓系数（Silhouette Coefficient）是评价聚类效果好坏的一种方法，用来衡量簇的密集与分散程度。它结合内聚度和分离度两种因素，可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。轮廓系数取值为[-1,1],其值越大表示同类中样本距离最近，不同类中样本距离最远，即该值越接近于1，簇越紧凑，聚类效果越好。</p>
<p>使用K-means算法，将待分类数据集分为了 k 个类簇，对于其中的一个点 i 来说，a(i)表示该向量到它所属类簇中其他点的平均距离，b(i)表示该向量到其他类簇中点的平均距离。对于一个样本集合，所有样本的轮廓系数的平均值即为该聚类结果总的轮廓系数。</p>
<ul>
<li>误差平方和</li>
</ul>
<p>误差平方和又称残差平方和、组内平方和等。根据n个观察值拟合适当的模型后，余下未能拟合部份(ei=yi-y平均)称为残差，其中y平均表示n个观察值的平均值，所有n个残差平方之和称误差平方和。</p>
<p>当K取不同值时，计算所得误差平方和如下所示：</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E8%AF%AF%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C.png" alt></p>
<p>计算所得的轮廓系数如下图所示，结合误差平方和和轮廓系数，当k=6时，有着较好的聚类效果。</p>
<p><img src="//jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0.png" alt></p>
<h3 id="3-3结果分析"><a href="#3-3结果分析" class="headerlink" title="3.3结果分析"></a>3.3结果分析</h3><p>首先，通过LDA主题模型，可以计算出文档数据集的文档-主题分布情况和主题-单词的分布情况，训练得出的主题数即为类簇数。</p>
<p>对LDA训练的文档-主题分布结果，即将文档表示成在不同主题上的分布所组成的向量，由于LDA考虑到了词之间的语义关系，所以该特征向量能够更好地反应文档的信息，因此可以将其作为K-means聚类算法的输入，从而弥补基于空间向量模型的K-means算法的缺点。经过实验发现，在类簇K为6时，轮廓系数为65.9661577458792，误差平方和为0.8266340036962969，聚类效果良好。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要介绍Spark平台下基于LDA的k-means算法实现。对文本挖掘进行了详细设计，在公开数据集上训练LDA模型，并对文档-主题分布和主题-词语分布进行了详细说明。最后实现了基于LDA的K-means聚类算法，克服了传统K-means算法的缺陷。</p>
<blockquote>
<p>公众号『大数据技术与数仓』，回复『资料』领取大数据资料包</p>
</blockquote>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/08/07/一文搞懂HBase的基本原理/" target="_blank">内含面试|一文搞懂HBase的基本原理</a></li><li><a href="https://jiamaoxiang.top/2020/08/06/数仓面试-四个在工作后才知道的SQL密技/" target="_blank">数仓面试|四个在工作后才知道的SQL密技</a></li><li><a href="https://jiamaoxiang.top/2020/07/31/第六篇-Spark-MLLib机器学习/" target="_blank">第六篇|Spark MLLib机器学习(1)</a></li><li><a href="https://jiamaoxiang.top/2020/07/29/第五篇-Spark-Streaming编程指南-2/" target="_blank">第五篇|Spark-Streaming编程指南(2)</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/">https://jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/08/02/第七篇-Spark平台下基于LDA的k-means算法实现/" data-id="ckhrsor290059l87q0bkzhsm9" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJUlEQVR42u3aS27DMAwFwN7/0ukBWsePpAJYymhVOIGsURYsPz8/8Xr9WVefvt9h/nzyzfLCxsbG3oT9eruqsGSH5PkV7P2pEgs2Njb2qezJyz4RP5PdrtjRbtjY2NhfzM7DVXK4yYViY2NjY0/YecmpWuFJrqZ6TmxsbOxvYOcBqXdByXHnjYeP1NKwsbGxH8+ulnie/PdH+tvY2NjYD2a/iquXliQ7TEaCygpsbGzsg9iTlmoPUC1CVRsPhfNjY2NjH8rOizKv1qo2eueBs5BdYWNjY2/LTsr3vQZw9YImYzr5c2xsbOzz2PlATB7weulH76KTYImNjY19KrsXivJANQ9+vTzi5jk2Njb2QezeP/fVgZ68zJQHoSSBuTk/NjY29kHsanCqkvK3lINQfMIFMRkbGxv7kexqcOqFt7VFpUmjupCBYWNjY2/Irm43CUuFkZpx0+KmloaNjY19BHtSmsmDRy+9WZBjJVU0bGxs7G3ZvZZqUsrPmwfl8DNoHpfx2NjY2I9nryrozws9nxjNvDw5NjY29nHsauGm2jCYjNqsKnv9E8CwsbGxj2MnRZ/eN3sjOPOdL8MYNjY29nHspDyUJw/5QXvpSvXKbhq92NjY2Juzq6ReM7XaMFjV6G2GMWxsbOzN2atK/JOm76TNXGhpYGNjYx/BToJHNaRNfoHeu/Igd9kVwcbGxt6WPUkhqoDkoPmFJoHwZk9sbGzsI9i9xsC8xNNrJ/cWNjY29rexV43IVPcppBDz0IuNjY19EHsSYHqX1QuNvbSnG9+wsbGx92OvSgOq5Z7q5U4C1WVCgo2NjX0oOxmmWTtGU002kn1uAhs2Njb2oezq4E5vuKfakFjVQrgc2cHGxsbelv0qrrzEnx90TqoWrbCxsbFPYq/aelIeyq+mV7pK0ipsbGzs3dl5mrG2FNVrNkwCFTY2NvbZ7CRsJOzqseajnHnLARsbGxs7T0uqeU9etOqd8LKiho2Njf3F7OrATZ4qVFsUvcQGGxsb+zx2dRxn3pStXs1kDGhUS8PGxsZ+PLtaoOmlH6sGevIGxoIfDBsbG/vp7F81tJpGfMBFsQAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Spark/">Spark</a></div><div class="post-nav"><a class="pre" href="/2020/08/06/数仓面试-四个在工作后才知道的SQL密技/">数仓面试|四个在工作后才知道的SQL密技</a><a class="next" href="/2020/07/31/第六篇-Spark-MLLib机器学习/">第六篇|Spark MLLib机器学习(1)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-文本挖掘模块设计"><span class="toc-number">1.</span> <span class="toc-text">1.文本挖掘模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1文本挖掘流程"><span class="toc-number">1.1.</span> <span class="toc-text">1.1文本挖掘流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2文本挖掘流程分析"><span class="toc-number">1.2.</span> <span class="toc-text">1.2文本挖掘流程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-文本挖掘模块算法研究"><span class="toc-number">2.</span> <span class="toc-text">2.文本挖掘模块算法研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1LDA主题模型算法"><span class="toc-number">2.1.</span> <span class="toc-text">2.1LDA主题模型算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2K均值算法"><span class="toc-number">2.2.</span> <span class="toc-text">2.2K均值算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3文本挖掘算法优化"><span class="toc-number">2.3.</span> <span class="toc-text">2.3文本挖掘算法优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-实验分析"><span class="toc-number">3.</span> <span class="toc-text">3.实验分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1基于Spark的LDA主题模型算法实现"><span class="toc-number">3.1.</span> <span class="toc-text">3.1基于Spark的LDA主题模型算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据集介绍"><span class="toc-number">3.1.1.</span> <span class="toc-text">数据集介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原始数据集处理"><span class="toc-number">3.1.2.</span> <span class="toc-text">原始数据集处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k折交叉验证确定训练参数"><span class="toc-number">3.1.3.</span> <span class="toc-text">k折交叉验证确定训练参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验结果"><span class="toc-number">3.1.4.</span> <span class="toc-text">实验结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2Spark平台下基于LDA的k-means算法实现"><span class="toc-number">3.2.</span> <span class="toc-text">3.2Spark平台下基于LDA的k-means算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据预处理"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模型训练"><span class="toc-number">3.2.2.</span> <span class="toc-text">模型训练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模型评估"><span class="toc-number">3.2.3.</span> <span class="toc-text">模型评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3结果分析"><span class="toc-number">3.3.</span> <span class="toc-text">3.3结果分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>