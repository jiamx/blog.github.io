<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>透过窗口看无限数据流——Flink的Window全面解析 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">透过窗口看无限数据流——Flink的Window全面解析</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">透过窗口看无限数据流——Flink的Window全面解析</h1><div class="post-meta">May 5, 2020<span> | </span><span class="category"><a href="/categories/Flink/">Flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 8.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 35</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><a id="more"></a>

<p>窗口是流式计算中非常常用的算子之一，通过窗口可以将无限流切分成有限流，然后在每个窗口之上使用计算函数，可以实现非常灵活的操作。Flink提供了丰富的窗口操作，除此之外，用户还可以根据自己的处理场景自定义窗口。通过本文，你可以了解到：</p>
<ul>
<li>窗口的基本概念和简单使用</li>
<li>内置Window Assigners的分类、源码及使用</li>
<li>Window Function的分类及使用</li>
<li>窗口的组成部分及生命周期源码解读</li>
<li>完整的窗口使用Demo案例</li>
</ul>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Window(窗口)是处理无界流的核心算子，Window可以将数据流分为固定大小的”桶(buckets)”(即通过按照固定时间或长度将数据流切分成不同的窗口)，在每一个窗口上，用户可以使用一些计算函数对窗口内的数据进行处理，从而得到一定时间范围内的统计结果。比如统计每隔5分钟输出最近一小时内点击量最多的前 N 个商品，这样就可以使用一个小时的时间窗口将数据限定在固定时间范围内，然后可以对该范围内的有界数据执行聚合处理。</p>
<p>根据作用的数据流(DataStream、KeyedStream)，Window可以分为两种：<strong>Keyed Windows</strong>与<strong>Non-Keyed Windows</strong>。其中Keyed Windows是在KeyedStream上使用window(…)操作，产生一个WindowedStream。Non-Keyed Windows是在DataStream上使用windowAll(…)操作，产生一个AllWindowedStream。具体的转换关系如下图所示。注意：一般不推荐使用<code>AllWindowedStream</code>，因为在普通流上进行窗口操作，会将所有分区的流都汇集到单个的Task中，即并行度为1，从而会影响性能。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/%E6%B5%81%E8%BD%AC%E6%8D%A2.png" alt></p>
<h3 id="如何用"><a href="#如何用" class="headerlink" title="如何用"></a>如何用</h3><p>上面我们介绍了什么是窗口，那么该如何使用窗口呢?具体如下面的代码片段：</p>
<h4 id="Keyed-Windows"><a href="#Keyed-Windows" class="headerlink" title="Keyed Windows"></a>Keyed Windows</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream</span><br><span class="line">       .keyBy(...)               <span class="comment">// keyedStream上使用window</span></span><br><span class="line">       .window(...)              <span class="comment">// 必选: 指定窗口分配器( window assigner)</span></span><br><span class="line">      [.trigger(...)]            <span class="comment">// 可选: 指定触发器(trigger),如果不指定，则使用默认值</span></span><br><span class="line">      [.evictor(...)]            <span class="comment">// 可选: 指定清除器(evictor),如果不指定，则没有</span></span><br><span class="line">      [.allowedLateness(...)]    <span class="comment">// 可选: 指定是否延迟处理数据，如果不指定，默认使用0 </span></span><br><span class="line">      [.sideOutputLateData(...)] <span class="comment">// 可选: 配置side output，如果不指定，则没有</span></span><br><span class="line">       .reduce/aggregate/fold/apply() <span class="comment">// 必选: 指定窗口计算函数</span></span><br><span class="line">      [.getSideOutput(...)]      <span class="comment">// 可选: 从side output中获取数据</span></span><br></pre></td></tr></table></figure>

<h4 id="Non-Keyed-Windows"><a href="#Non-Keyed-Windows" class="headerlink" title="Non-Keyed Windows"></a>Non-Keyed Windows</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream</span><br><span class="line">       .windowAll(...)           <span class="comment">// 必选: 指定窗口分配器( window assigner)</span></span><br><span class="line">      [.trigger(...)]            <span class="comment">// 可选: 指定触发器(trigger),如果不指定，则使用默认值</span></span><br><span class="line">      [.evictor(...)]            <span class="comment">// 可选: 指定清除器(evictor),如果不指定，则没有</span></span><br><span class="line">      [.allowedLateness(...)]    <span class="comment">// 可选: 指定是否延迟处理数据，如果不指定，默认使用0</span></span><br><span class="line">      [.sideOutputLateData(...)] <span class="comment">// 可选: 配置side output，如果不指定，则没有</span></span><br><span class="line">       .reduce/aggregate/fold/apply() <span class="comment">// 必选: 指定窗口计算函数</span></span><br><span class="line">      [.getSideOutput(...)]      <span class="comment">// 可选: 从side output中获取数据</span></span><br></pre></td></tr></table></figure>

<h3 id="简写window操作"><a href="#简写window操作" class="headerlink" title="简写window操作"></a>简写window操作</h3><p>上面的代码片段中，要在keyedStream上使用window(…)或者在DataStream上使用windowAll(…)，需要传入一个window assigner的参数，关于window assigner下文会进行详细解释。如下面代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">//  Keyed Windows</span></span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">stream</span><br><span class="line">       .keyBy(id)               </span><br><span class="line">       .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>))) <span class="comment">// 5S的滚动窗口</span></span><br><span class="line">       .reduce(MyReduceFunction)</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">//  Non-Keyed Windows</span></span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">stream               </span><br><span class="line">       .windowAll(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>))) <span class="comment">// 5S的滚动窗口</span></span><br><span class="line">       .reduce(MyReduceFunction)</span><br></pre></td></tr></table></figure>

<p>上面的代码可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">//  Keyed Windows</span></span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">stream</span><br><span class="line">       .keyBy(id)               </span><br><span class="line">       .timeWindow(Time.seconds(<span class="number">5</span>)) <span class="comment">// 5S的滚动窗口</span></span><br><span class="line">       .reduce(MyReduceFunction)</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">//  Non-Keyed Windows</span></span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line">stream               </span><br><span class="line">       .timeWindowAll(Time.seconds(<span class="number">5</span>)) <span class="comment">// 5S的滚动窗口</span></span><br><span class="line">       .reduce(MyReduceFunction)</span><br></pre></td></tr></table></figure>

<p>关于上面的简写，以KeyedStream为例，对于看一下具体的KeyedStream源码片段，可以看出底层调用的还是非简写时的代码。关于timeWindowAll()的代码也是一样的，可以参考DataStream源码，这里不再赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会根据用户的使用的时间类型，调用不同的内置window Assigner</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">			<span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Window-Assigners"><a href="#Window-Assigners" class="headerlink" title="Window Assigners"></a>Window Assigners</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>WindowAssigner负责将输入的数据分配到一个或多个窗口，Flink内置了许多WindowAssigner，这些WindowAssigner可以满足大部分的使用场景。比如<strong>tumbling windows</strong>, <strong>sliding windows</strong>, <strong>session windows</strong> , <strong>global windows</strong>。如果这些内置的WindowAssigner不能满足你的需求，可以通过继承WindowAssigner类实现自定义的WindowAssigner。</p>
<p>上面的WindowAssigner是基于时间的(time-based windows)，除此之外，Flink还提供了基于数量的窗口(count-based windows),即根据窗口的元素数量定义窗口大小，这种情况下，如果数据存在乱序，将导致窗口计算结果不确定。本文重点介绍基于时间的窗口使用，由于篇幅有限，关于基于数量的窗口将不做讨论。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/windowassigner%E5%88%86%E7%B1%BB1.png" alt></p>
<h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><p>下面将会对Flink内置的四种基于时间的windowassigner，进行一一分析。</p>
<h4 id="Tumbling-Windows"><a href="#Tumbling-Windows" class="headerlink" title="Tumbling Windows"></a>Tumbling Windows</h4><ul>
<li>图解</li>
</ul>
<p>Tumbling Windows(滚动窗口)是将数据分配到确定的窗口中，根据固定时间或大小进行切分，每个窗口有固定的大小且窗口之间不存在重叠(如下图所示)。这种比较简单，适用于按照周期统计某一指标的场景。</p>
<p>关于时间的选择，可以使用Event Time或者Processing Time，分别对应的window assigner为：TumblingEventTimeWindows、TumblingProcessingTimeWindows。用户可以使用window assigner的of(size)方法指定时间间隔，其中时间单位可以是Time.milliseconds(x)、Time.seconds(x)或Time.minutes(x)等。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/tumblingwindow.png" alt></p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用EventTime</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br><span class="line"><span class="comment">// 使用processing-time</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br></pre></td></tr></table></figure>

<h4 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h4><ul>
<li>图解</li>
</ul>
<p>Sliding Windows(滑动窗口)在滚动窗口之上加了一个滑动窗口的时间，这种类型的窗口是会存在窗口重叠的(如下图所示)。滚动窗口是按照窗口固定的时间大小向前滚动，而滑动窗口是根据设定的滑动时间向前滑动。窗口之间的重叠部分的大小取决于窗口大小与滑动的时间大小，当滑动时间小于窗口时间大小时便会出现重叠。当滑动时间大于窗口时间大小时，会出现窗口不连续的情况，导致数据可能不属于任何一个窗口。当两者相等时，其功能就和滚动窗口相同了。滑动窗口的使用场景是：用户根据设定的统计周期来计算指定窗口时间大小的指标，比如每隔5分钟输出最近一小时内点击量最多的前 N 个商品。</p>
<p>关于时间的选择，可以使用Event Time或者Processing Time，分别对应的window assigner为：SlidingEventTimeWindows、SlidingProcessingTimeWindows。用户可以使用window assigner的of(size)方法指定时间间隔，其中时间单位可以是Time.milliseconds(x)、Time.seconds(x)或Time.minutes(x)等。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/slidewindow.png" alt></p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用EventTime</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br><span class="line"><span class="comment">// 使用processing-time</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br></pre></td></tr></table></figure>

<h4 id="Session-Windows"><a href="#Session-Windows" class="headerlink" title="Session Windows"></a>Session Windows</h4><ul>
<li>图解</li>
</ul>
<p>Session Windows(会话窗口)主要是将某段时间内活跃度较高的数据聚合成一个窗口进行计算，窗口的触发的条件是Session Gap，是指在规定的时间内如果没有数据活跃接入，则认为窗口结束，然后触发窗口计算结果。需要注意的是如果数据一直不间断地进入窗口，也会导致窗口始终不触发的情况。与滑动窗口、滚动窗口不同的是，Session Windows不需要有固定窗口大小(window size)和滑动时间(slide time)，只需要定义session gap，来规定不活跃数据的时间上限即可。如下图所示。Session Windows窗口类型比较适合非连续型数据处理或周期性产生数据的场景，根据用户在线上某段时间内的活跃度对用户行为数据进行统计。</p>
<p>关于时间的选择，可以使用Event Time或者Processing Time，分别对应的window assigner为：EventTimeSessionWindows和ProcessTimeSessionWindows。用户可以使用window assigner的withGap()方法指定时间间隔，其中时间单位可以是Time.milliseconds(x)、Time.seconds(x)或Time.minutes(x)等。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/sessionwindow.png" alt></p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用EventTime</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window((EventTimeSessionWindows.withGap(Time.minutes(<span class="number">15</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br><span class="line"><span class="comment">// 使用processing-time</span></span><br><span class="line">datastream</span><br><span class="line">           .keyBy(id)</span><br><span class="line">           .window(ProcessingTimeSessionWindows.withGap(Time.minutes(<span class="number">15</span>)))</span><br><span class="line">           .process(<span class="keyword">new</span> MyProcessFunction())</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>由于session window的开始时间与结束时间取决于接收的数据。windowassigner不会立即分配所有的元素到正确的窗口，SessionWindow会为每个接收的元素初始化一个以该元素的时间戳为开始时间的窗口，使用session gap作为窗口大小，然后再合并重叠部分的窗口。所以， session window 操作需要指定用于合并的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/windows.html#triggers" target="_blank" rel="noopener">Trigger</a> 和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/windows.html#window-functions" target="_blank" rel="noopener">Window Function</a>，比如<code>ReduceFunction</code>, <code>AggregateFunction</code>, or <code>ProcessWindowFunction</code>。</p>
<h4 id="Global-Windows"><a href="#Global-Windows" class="headerlink" title="Global Windows"></a>Global Windows</h4><ul>
<li>图解</li>
</ul>
<p>Global Windows(全局窗口)将所有相同的key的数据分配到单个窗口中计算结果，窗口没有起始和结束时间，窗口需要借助于Triger来触发计算，如果不对Global Windows指定Triger，窗口是不会触发计算的。因此，使用Global Windows需要非常慎重，用户需要非常明确自己在整个窗口中统计出的结果是什么，并指定对应的触发器，同时还需要有指定相应的数据清理机制，否则数据将一直留在内存中。</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/globalwindow.png" alt></p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">datastream</span><br><span class="line">    .keyBy(id)</span><br><span class="line">    .window(GlobalWindows.create())</span><br><span class="line">    .process(<span class="keyword">new</span> MyProcessFunction())</span><br></pre></td></tr></table></figure>

<h2 id="Window-Functions"><a href="#Window-Functions" class="headerlink" title="Window Functions"></a>Window Functions</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>Flink提供了两大类窗口函数，分别为增量聚合函数和全量窗口函数。其中增量聚合函数的性能要比全量窗口函数高，因为增量聚合窗口是基于中间结果状态计算最终结果的，即窗口中只维护一个中间结果状态，不要缓存所有的窗口数据。相反，对于全量窗口函数而言，需要对所以进入该窗口的数据进行缓存，等到窗口触发时才会遍历窗口内所有数据，进行结果计算。如果窗口数据量比较大或者窗口时间较长，就会耗费很多的资源缓存数据，从而导致性能下降。</p>
<ul>
<li><p>增量聚合函数</p>
<p>包括：ReduceFunction、AggregateFunction和FoldFunction</p>
</li>
<li><p>全量窗口函数</p>
<p>包括：ProcessWindowFunction</p>
</li>
</ul>
<h3 id="使用介绍-1"><a href="#使用介绍-1" class="headerlink" title="使用介绍"></a>使用介绍</h3><h4 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h4><p>输入两个相同类型的数据元素按照指定的计算方法进行聚合，然后输出类型相同的一个结果元素。要求输入元素的数据类型与输出元素的数据类型必须一致。实现的效果是使用上一次的结果值与当前值进行聚合。具体使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceFunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>)).assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        input</span><br><span class="line">                .map(<span class="keyword">new</span> MapFunction&lt;Tuple3&lt;Long, Integer, Long&gt;, Tuple2&lt;Long, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">map</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; value)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(value.f0, value.f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;Long, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;Long, Integer&gt; value1, Tuple2&lt;Long, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 根据第一个元素分组，求第二个元素的累计和</span></span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"ReduceFunctionExample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h4><p>与ReduceFunction相似，AggregateFunction也是基于中间状态计算结果的增量计算函数，相比ReduceFunction，AggregateFunction在窗口计算上更加灵活，但是实现稍微复杂，需要实现AggregateFunction接口，重写四个方法。其最大的优势就是中间结果的数据类型和最终的结果类型不依赖于输入的数据类型。关于AggregateFunction的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">*  <span class="doctag">@param</span> &lt;IN&gt;  输入元素的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;ACC&gt; 中间聚合结果的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; 最终聚合结果的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AggregateFunction</span>&lt;<span class="title">IN</span>, <span class="title">ACC</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个新的累加器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ACC <span class="title">createAccumulator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将新的数据与累加器进行聚合，返回一个新的累加器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ACC <span class="title">add</span><span class="params">(IN value, ACC accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 从累加器中计算最终结果并返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">OUT <span class="title">getResult</span><span class="params">(ACC accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 合并两个累加器并返回结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ACC <span class="title">merge</span><span class="params">(ACC a, ACC b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体使用代码案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregateFunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>)).assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        input.keyBy(<span class="number">0</span>)</span><br><span class="line">             .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">             .aggregate(<span class="keyword">new</span> MyAggregateFunction()).print();</span><br><span class="line">        env.execute(<span class="string">"AggregateFunctionExample"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAggregateFunction</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt;,<span class="title">Tuple2</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>&gt;,<span class="title">Tuple2</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个累加器,初始化值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(<span class="number">0L</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value 输入的元素值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator 中间结果值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">add</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; value, Tuple2&lt;Long, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(value.f0,value.f1 + accumulator.f1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取计算结果值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(accumulator.f0,accumulator.f1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 合并中间结果值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a 中间结果值a</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> b 中间结果值b</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Integer&gt; a, Tuple2&lt;Long, Integer&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(a.f0,a.f1 + b.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FoldFunction"><a href="#FoldFunction" class="headerlink" title="FoldFunction"></a>FoldFunction</h4><p>FoldFunction定义了如何将窗口中的输入元素与外部的元素合并的逻辑,该接口已标记过时，建议用户使用AggregateFunction来替换使用FoldFunction。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldFunctionExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>)).assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        input.keyBy(<span class="number">0</span>)</span><br><span class="line">             .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">             .fold(<span class="string">"用户"</span>,<span class="keyword">new</span> FoldFunction&lt;Tuple3&lt;Long, Integer, Long&gt;,String&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> String <span class="title">fold</span><span class="params">(String accumulator, Tuple3&lt;Long, Integer, Long&gt; value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 为第一个元素的值拼接一个"用户"字符串,进行输出</span></span><br><span class="line">                     <span class="keyword">return</span> accumulator + value.f0 ;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;).print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"FoldFunctionExample"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h4><p>前面提到的ReduceFunction和AggregateFunction都是基于中间状态实现增量计算的窗口函数。有些时候需要使用整个窗口的所有数据进行计算，比如求中位数和众数。另外，ProcessWindowFunction的Context对象可以访问窗口的一些元数据信息，比如窗口结束时间、水位线等。ProcessWindowsFunction能够更加灵活地支持基于窗口全部数据元素的结果计算。</p>
<p>在系统内部，由ProcessWindowFunction处理的窗口会将所有已分配的数据存储到ListState中，通过将数据收集起来且提供对于窗口的元数据及其他一些特性的访问和使用，应用场景比ReduceFunction和AggregateFunction更加广泛。关于ProcessWindowFunction抽象类的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt; 输入的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; 输出的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;KEY&gt; key的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; window的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算窗口数据，输出0个或多个元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key 窗口的key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context 窗口的上下文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> elements 窗口内的所有元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> out 输出元素的collector对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当窗口被销毁时，删除状态</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//context可以访问窗口的元数据信息.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回当前被计算的窗口</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回当前processing time. </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回当前event-time 水位线.</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//每个key和每个window的状态访问器</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 每个key的global state的状态访问器.</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向side output输出数据</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125;  side output 输出的标识.</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> value 输出的数据.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunctionExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>)).assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        input.keyBy(t -&gt; t.f0)</span><br><span class="line">             .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">             .process(<span class="keyword">new</span> MyProcessWindowFunction())</span><br><span class="line">             .print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt;,<span class="title">Tuple3</span>&lt;<span class="title">Long</span>,<span class="title">String</span>,<span class="title">Integer</span>&gt;,<span class="title">Long</span>,<span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                Long aLong,</span></span></span><br><span class="line"><span class="function"><span class="params">                Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                Iterable&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                Collector&lt;Tuple3&lt;Long, String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Tuple3&lt;Long, Integer, Long&gt; in: elements) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计每个窗口数据个数，加上窗口输出</span></span><br><span class="line">            out.collect(Tuple3.of(aLong,<span class="string">""</span> + context.window(),count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增量聚合函数和ProcessWindowFunction整合"><a href="#增量聚合函数和ProcessWindowFunction整合" class="headerlink" title="增量聚合函数和ProcessWindowFunction整合"></a>增量聚合函数和ProcessWindowFunction整合</h4><p>ProcessWindowFunction提供了很强大的功能，但是唯一的缺点就是需要更大的状态存储数据。在很多时候，增量聚合的使用是非常频繁的，那么如何实现既支持增量聚合又支持访问窗口元数据的操作呢？可以将ReduceFunction和AggregateFunction与ProcessWindowFunction整合在一起使用。通过这种组合方式，分配给窗口的元素会立即被执行计算，当窗口触发时，会把聚合的结果传给ProcessWindowFunction，这样ProcessWindowFunction的process方法的Iterable参数被就只有一个值，即增量聚合的结果。</p>
<ul>
<li>ReduceFunction与ProcessWindowFunction组合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceProcessWindowFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>)).assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        input.map(<span class="keyword">new</span> MapFunction&lt;Tuple3&lt;Long, Integer, Long&gt;, Tuple2&lt;Long, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">map</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(value.f0, value.f1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">             .keyBy(t -&gt; t.f0)</span><br><span class="line">             .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">             .reduce(<span class="keyword">new</span> MyReduceFunction(),<span class="keyword">new</span> MyProcessWindowFunction())</span><br><span class="line">             .print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"ProcessWindowFunctionExample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title">ReduceFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;Long, Integer&gt; value1, Tuple2&lt;Long, Integer&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//增量求和</span></span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(value1.f0,value1.f1 + value2.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>&gt;,<span class="title">Tuple3</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>,<span class="title">String</span>&gt;,<span class="title">Long</span>,<span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Long aLong, Context ctx, Iterable&lt;Tuple2&lt;Long, Integer&gt;&gt; elements, Collector&lt;Tuple3&lt;Long, Integer, String&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 将求和之后的结果附带窗口结束时间一起输出</span></span><br><span class="line">            out.collect(Tuple3.of(aLong,elements.iterator().next().f1,<span class="string">"window_end"</span> + ctx.window().getEnd()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AggregateFunction与ProcessWindowFunction组合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AggregateProcessWindowFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, Integer, Long&gt;&gt; input = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">10</span>, <span class="number">1588491228L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">15</span>, <span class="number">1588491229L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">20</span>, <span class="number">1588491238L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">1L</span>, <span class="number">25</span>, <span class="number">1588491248L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">10</span>, <span class="number">1588491258L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">30</span>, <span class="number">1588491268L</span>),</span><br><span class="line">                Tuple3.of(<span class="number">2L</span>, <span class="number">20</span>, <span class="number">1588491278L</span>))</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, Integer, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.f2 * <span class="number">1000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        input.keyBy(t -&gt; t.f0)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">                .aggregate(<span class="keyword">new</span> MyAggregateFunction(),<span class="keyword">new</span> MyProcessWindowFunction())</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"AggregateFunctionExample"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAggregateFunction</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>&gt;, <span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个累加器,初始化值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(<span class="number">0L</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value       输入的元素值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator 中间结果值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">add</span><span class="params">(Tuple3&lt;Long, Integer, Long&gt; value, Tuple2&lt;Long, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(value.f0, value.f1 + accumulator.f1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取计算结果值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(accumulator.f0, accumulator.f1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 合并中间结果值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a 中间结果值a</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> b 中间结果值b</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Integer&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Integer&gt; a, Tuple2&lt;Long, Integer&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(a.f0, a.f1 + b.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>&gt;,<span class="title">Tuple3</span>&lt;<span class="title">Long</span>,<span class="title">Integer</span>,<span class="title">String</span>&gt;,<span class="title">Long</span>,<span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Long aLong, Context ctx, Iterable&lt;Tuple2&lt;Long, Integer&gt;&gt; elements, Collector&lt;Tuple3&lt;Long, Integer, String&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 将求和之后的结果附带窗口结束时间一起输出</span></span><br><span class="line">            out.collect(Tuple3.of(aLong,elements.iterator().next().f1,<span class="string">"window_end"</span> + ctx.window().getEnd()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="window-生命周期解读"><a href="#window-生命周期解读" class="headerlink" title="window 生命周期解读"></a>window 生命周期解读</h2><h3 id="生命周期图解"><a href="#生命周期图解" class="headerlink" title="生命周期图解"></a>生命周期图解</h3><p>窗口从创建到执行窗口计算再到被清除，需要经过一系列的过程，这个过程就是窗口的生命周期。</p>
<p>首先，当一个元素进入窗口算子之前，会由WindowAssigner分配该元素进入哪个或哪几个窗口，如果窗口不存在，则创建窗口。</p>
<p>其次，数据进入了窗口，这时要看有没有使用增量聚合函数，如果使用了增量聚合函数ReduceFunction或AggregateFunction，新加入窗口的元素会立即触发增量计算，计算的结果作为窗口的内容。如果没有使用增量聚合函数，则会将进入窗口的数据存储到ListState状态中，进一步等待窗口触发时，遍历窗口元素进行聚合计算。</p>
<p>然后，每个元素在进入窗口之后会传递至该窗口的触发器，触发器决定了窗口何时被执行计算及何时需要清除自身和保存的内容。触发器可以根据已分配的元素或注册的计时器来决定某些特定时刻执行窗口计算或清除窗口内容。</p>
<p>最后，触发器成功触发之后的操作取决于使用的窗口函数，如果使用的是增量聚合函数，如ReduceFunction或AggregateFunction，则会直接输出聚合的结果。如果只包含一个全量窗口函数，如ProcessWindowFunction，则会作用窗口的所有元素，执行计算，输出结果。如果组合使用了ReduceFunction和ProcessWindowFunction，即组合使用了增量聚合窗口函数和全量窗口函数，全量窗口函数会作用于增量聚合函数的聚合值，然后再输出最终的结果。</p>
<ul>
<li>情况1：仅使用增量聚合窗口函数</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88.png" alt></p>
<ul>
<li>情况2：仅使用全量窗口函数</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/%E5%85%A8%E9%87%8F%E7%AA%97%E5%8F%A3.png" alt></p>
<ul>
<li>情况3：组合使用增量聚合窗口函数与全量窗口函数</li>
</ul>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/%E7%BB%84%E5%90%88.png" alt></p>
<h3 id="分配器-Window-Assigners"><a href="#分配器-Window-Assigners" class="headerlink" title="分配器(Window Assigners)"></a>分配器(Window Assigners)</h3><p>WindowAssigner的作用是将输入的元素分配到一个或多个窗口，当WindowAssigner将第一个元素分配到窗口时，就会创建该窗口，所以一个窗口一旦被创建，窗口中必然至少有一个元素。Flink内置了很多WindowAssigners,本文主要讨论基于时间的WindowAssigners，这些分配器都继承了WindowAssigner抽象类。关于常用的分配器，上文已经做了详细解释。下面先来看一下继承关系图：</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/windowassigner%E7%BB%A7%E6%89%BF.png" alt></p>
<p>接下来，将会对WindowAssigner抽象类的源码进行分析，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WindowAssigner分配一个元素到0个或多个窗口</span></span><br><span class="line"><span class="comment"> * 在一个窗口算子内部，元素是按照key进行分组的(使用KeyedStream),</span></span><br><span class="line"><span class="comment"> * 相同key和window的元素集合称之为一个pane(格子)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 要分配元素的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; window的类型:TimeWindow、GlobalWindow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssigner</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回一个向其分配元素的窗口集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element 待分配的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timestamp 元素的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context WindowAssignerContext对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;W&gt; <span class="title">assignWindows</span><span class="params">(T element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回一个与该WindowAssigner相关的默认trigger(触发器)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> env 执行环境</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Trigger&lt;T, W&gt; <span class="title">getDefaultTrigger</span><span class="params">(StreamExecutionEnvironment env)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回一个窗口序列化器</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> executionConfig</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TypeSerializer&lt;W&gt; <span class="title">getWindowSerializer</span><span class="params">(ExecutionConfig executionConfig)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果元素是基于event time分配到窗口的，则返回true</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEventTime</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该Context允许访问当前的处理时间processing time</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssignerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回当前的处理时间</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发器-Triggers"><a href="#触发器-Triggers" class="headerlink" title="触发器(Triggers)"></a>触发器(Triggers)</h3><p>数据接入窗口后，窗口是否触发WindowFunciton计算，取决于窗口是否满足触发条件。Triggers就是决定窗口何时触发计算并输出结果的条件，Triggers可以根据时间或者具体的数据条件进行触发，比如进入窗口元素的个数或者进入窗口的某些特定的元素值等。前面讨论的内置WindowAssigner都有各自默认的触发器，当使用的是Processing Time时，则当处理时间超过窗口结束时间时会被触发。当使用Event Time时，当水位线超过窗口结束时间时会被触发。</p>
<p>Flink在内部提供很多内置的触发器，常用的主要有EventTimeTrigger、ProcessTimeTrigger以及CountTrigger等。每种每种触发器都对应于不同的Window Assigner，例如Event Time类型的Windows对应的触发器是EventTimeTrigger，其基本原理是判断当前的Watermark是否超过窗口的EndTime，如果超过则触发对窗口内数据的计算，反之不触发计算。关于上面分析的内置WindowAssigner的默认trigger，可以从各自的源码中看到，具体罗列如下：</p>
<table>
<thead>
<tr>
<th>分配器</th>
<th>对应的源码</th>
<th>默认触发器</th>
</tr>
</thead>
<tbody><tr>
<td>TumblingEventTimeWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   EventTimeTrigger.create();       }</td>
<td>EventTimeTrigger</td>
</tr>
<tr>
<td>TumblingProcessingTimeWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   ProcessingTimeTrigger.create();       }</td>
<td>ProcessingTimeTrigger</td>
</tr>
<tr>
<td>SlidingEventTimeWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   EventTimeTrigger.create();       }</td>
<td>EventTimeTrigger</td>
</tr>
<tr>
<td>SlidingProcessingTimeWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   ProcessingTimeTrigger.create();       }</td>
<td>ProcessingTimeTrigger</td>
</tr>
<tr>
<td>EventTimeSessionWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   EventTimeTrigger.create();       }</td>
<td>EventTimeTrigger</td>
</tr>
<tr>
<td>ProcessingTimeSessionWindows</td>
<td>public Trigger&lt;Object,   TimeWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return   ProcessingTimeTrigger.create();       }</td>
<td>ProcessingTimeTrigger</td>
</tr>
<tr>
<td>GlobalWindows</td>
<td>public Trigger&lt;Object,   GlobalWindow&gt; getDefaultTrigger(StreamExecutionEnvironment env) {        return new NeverTrigger();       }</td>
<td>NeverTrigger</td>
</tr>
</tbody></table>
<p>这些Trigger都继承了Trigger抽象类，具体的继承关系，如下图：</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/trigger%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt></p>
<p>关于这些内置的Trigger的具体解释如下：</p>
<table>
<thead>
<tr>
<th align="center">Trigger</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EventTimeTrigger</td>
<td align="left">当前的Watermark是否超过窗口的EndTime，如果超过则触发对窗口内数据的计算，反之不触发计算；</td>
</tr>
<tr>
<td align="center">ProcessTimeTrigger</td>
<td align="left">当前的Processing   Time是否超过窗口的EndTime，如果超过则触发对窗口内数据的计算，反之不触发计算；</td>
</tr>
<tr>
<td align="center">ContinuousEventTimeTrigger</td>
<td align="left">根据间隔时间周期性触发窗口或者Window的结束时间小于当前EventTime，触发窗口计算；</td>
</tr>
<tr>
<td align="center">ContinuousProcessingTimeTrigger</td>
<td align="left">根据间隔时间周期性触发窗口或者Window的结束时间小于当前ProcessTime，触发窗口计算；</td>
</tr>
<tr>
<td align="center">CountTrigger</td>
<td align="left">根据窗口的数据条数是否超过设定的阈值确定是否触发窗口计算；</td>
</tr>
<tr>
<td align="center">DeltaTrigger</td>
<td align="left">根据窗口的数据计算出来的Delta指标是否超过指定的阈值，判断是否触发窗口计算</td>
</tr>
<tr>
<td align="center">PurgingTrigger</td>
<td align="left">可以将任意触发器作为参数转换为Purge类型触发器，计算完成后数据将被清理。</td>
</tr>
</tbody></table>
<p>关于抽象类Trigger的源码解释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 元素的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; Window的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Trigger</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4104633972991191369L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每个元素被分配到窗口时都会调用该方法，返回一个TriggerResult枚举</span></span><br><span class="line"><span class="comment">	 * 该枚举包含很多触发的类型：CONTINUE、FIRE_AND_PURGE、FIRE、PURGE</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element   进入窗口的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timestamp 进入窗口元素的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window    窗口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctx       上下文对象，可以注册计时器(timer)回调函数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onElement</span><span class="params">(T element, <span class="keyword">long</span> timestamp, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当使用TriggerContext注册的processing-time计时器被触发时,会调用该方法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> time   触发计时器的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window 计时器触发的window</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctx    上下文对象，可以注册计时器(timer)回调函数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当使用TriggerContext注册的event-time计时器被触发时,会调用该方法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> time   触发计时器的时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window 计时器触发的window</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctx    上下文对象，可以注册计时器(timer)回调函数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果触发器支持合并触发器状态，将返回true</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当多个窗口被合并成一个窗口时，会调用该方法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window 合并之后的window</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctx    上下文对象，可以注册计时器回调函数，也可以访问状态</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMerge</span><span class="params">(W window, OnMergeContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"This trigger does not support merging."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 清除所有Trigger持有的窗口状态</span></span><br><span class="line"><span class="comment">	 * 当窗口被销毁时，调用该方法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Context对象，传给Trigger的方法参数中，用于注册计时器回调函数和处理状态</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 返回当前处理时间</span></span><br><span class="line">		<span class="function"><span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">MetricGroup <span class="title">getMetricGroup</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 返回当前水位线时间戳</span></span><br><span class="line">		<span class="function"><span class="keyword">long</span> <span class="title">getCurrentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 注册一个processing-time的计时器</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">		<span class="comment">// 注册一个EventTime计时器</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">		<span class="comment">//  删除一个processing-time的计时器</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">		<span class="comment">// 删除一个EventTime计时器</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 提取状态当前Trigger的窗口和Key的状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		&lt;S extends State&gt; <span class="function">S <span class="title">getPartitionedState</span><span class="params">(StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 与getPartitionedState功能相同，该方法已被标记过时</span></span><br><span class="line">		<span class="meta">@Deprecated</span></span><br><span class="line">		&lt;S extends Serializable&gt; <span class="function">ValueState&lt;S&gt; <span class="title">getKeyValueState</span><span class="params">(String name, Class&lt;S&gt; stateType, S defaultState)</span></span>;</span><br><span class="line">		<span class="comment">// 同getPartitionedState功能，该方法已被标记过时</span></span><br><span class="line">		<span class="meta">@Deprecated</span></span><br><span class="line">		&lt;S extends Serializable&gt; <span class="function">ValueState&lt;S&gt; <span class="title">getKeyValueState</span><span class="params">(String name, TypeInformation&lt;S&gt; stateType, S defaultState)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// TriggerContext的扩展</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnMergeContext</span> <span class="keyword">extends</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 合并每个window的状态，状态必须支持合并</span></span><br><span class="line">		&lt;S extends MergingState&lt;?, ?&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergePartitionedState</span><span class="params">(StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码可以看出,每当触发器调用时，会产生一个TriggerResult对象，该对象是一个枚举类，其包括的属性决定了作用在窗口上的操作是什么。总共有四种行为：CONTINUE、FIRE_AND_PURGE、FIRE、PURGE，关于每种类型的具体含义，我们先看一下TriggerResult源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发器方法的结果类型，决定在窗口上执行什么操作，比如是否调用window function</span></span><br><span class="line"><span class="comment"> * 或者是否需要销毁窗口</span></span><br><span class="line"><span class="comment"> * 注意：如果一个Trigger返回的是FIRE或者FIRE_AND_PURGE，但是窗口中没有任何元素，则窗口函数不会被调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TriggerResult &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 什么都不做，当前不触发计算，继续等待</span></span><br><span class="line">	CONTINUE(<span class="keyword">false</span>, <span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 window function，输出结果，之后清除所有状态</span></span><br><span class="line">	FIRE_AND_PURGE(<span class="keyword">true</span>, <span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 window function，输出结果，窗口不会被清除，数据继续保留</span></span><br><span class="line">	FIRE(<span class="keyword">true</span>, <span class="keyword">false</span>),</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 清除窗口内部数据，但不触发计算</span></span><br><span class="line">	PURGE(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清除器-Evictors"><a href="#清除器-Evictors" class="headerlink" title="清除器(Evictors)"></a>清除器(Evictors)</h3><p>Evictors是一个可选的组件，其主要作用是对进入WindowFuction前后的数据进行清除处理。Flink内置了三种Evictors：分别为CountEvictor、DeltaEvictor、TimeEvitor。如果用户不指定Evictors，也不会有默认值。</p>
<ul>
<li><strong>CountEvictor</strong>：保持在窗口中具有固定数量的元素，将超过指定窗口元素数量的数据在窗口计算前剔除；</li>
<li><strong>DeltaEvictor</strong>：通过定义DeltaFunction和指定threshold，并计算Windows中的元素与最新元素之间的Delta大小，如果超过threshold则将当前数据元素剔除；</li>
<li><strong>TimeEvictor</strong>：通过指定时间间隔，将当前窗口中最新元素的时间减去Interval，然后将小于该结果的数据全部剔除，其本质是将具有最新时间的数据选择出来，删除过时的数据。</li>
</ul>
<p>Evictors继承关系图如下：</p>
<p><img src="//jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/evictor.png" alt></p>
<p>关于Evictors接口的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在WindowFunction计算之前或者之后进行清除窗口元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 元素的数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; 窗口类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Evictor</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选择性剔除元素，在windowing function之前调用</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> elements 窗口中的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> size  窗口中元素个数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window 窗口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> evictorContext</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">evictBefore</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选择性剔除元素，在windowing function之后调用</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> elements 窗口中的元素.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> size 窗口中元素个数.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> window 窗口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> evictorContext</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">evictAfter</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line">	<span class="comment">// 传递给Evictor方法参数的值</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">EvictorContext</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 返回当前processing time</span></span><br><span class="line">		<span class="function"><span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">MetricGroup <span class="title">getMetricGroup</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">// 返回当前的水位线时间戳</span></span><br><span class="line">		<span class="function"><span class="keyword">long</span> <span class="title">getCurrentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文首先给出了窗口使用的快速入门，介绍了窗口的基本概念、分类及简单使用。然后对Flink内置的Window Assigner进行了一一解读，并给出了图解与使用的代码片段。接着对Flink的Window Function进行介绍，包括窗口函数的分类及详细使用案例。最后分析了Window生命周期所涉及的组件，并对每个组件的源码进行分析。</p>
</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/05/18/是时候换掉你的调度系统了/" target="_blank">是时候换掉你的调度系统了</a></li><li><a href="https://jiamaoxiang.top/2020/05/09/Flink-DataSet-API编程指南/" target="_blank">Flink DataSet API编程指南</a></li><li><a href="https://jiamaoxiang.top/2020/04/30/Flink-DataStream-API-中的多面手——Process-Function详解/" target="_blank">Flink DataStream API 中的多面手——Process Function详解</a></li><li><a href="https://jiamaoxiang.top/2020/04/25/Flink内部Exactly-Once三板斧-状态、状态后端与检查点/" target="_blank">Flink内部Exactly Once三板斧:状态、状态后端与检查点</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/">https://jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/05/05/透过窗口看无限数据流——Flink的Window全面解析/" data-id="ckaf5u7xc003cz47qzdn6rh6j" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADIklEQVR42u3aS3LCQAwFQO5/abJNVQA/SSaFRXtFOYSZHi9kfW63+Lr/uv7eT+68vqqr5H8dXdjY2NgXYVc3lGz32edn280P6/XDSCzY2NjYW9m9beUBJt/0O3aCjY2NjZ1/p3rn/w8OGxsbGztfpvfN6orY2NjY2HlRaR5s5nfyIHpaLQ0bGxv749l5V/TzP7+lv42NjY39wex78Ype8VtpySRwlhXY2NjYi9i9refLVyNI9cjyNAMbGxv729jJyGMvkCThqppmJL98S2IvNjY29iJ29efyYZok5egVtpKHF8VtbGxs7Auy87JOL4CdFRp7zWBsbGzs72HPF0j+qzdMkxxitcyEjY2NvYldba8mZaC8YJQnLWcNYmJjY2NvYlfHdPLCTZIezBOhfAyo2cfAxsbGvhQ7D06j8s246D8ZIXoQwLCxsbFXsHNSXrhphpbxdE30+9jY2NhL2T1AL9RVk5lJkHuwH2xsbOx17LNGbXppTDOdaDWno/YANjY29mXZvSZub2imenD5gUZBFBsbG3sdu3cckxJPfriT1sJBAMPGxsZexJ4kHsmrfxKWeo2Eapvh4N+wsbGxV7B7YaM6rJMf6GQo8+kdbGxs7HXsJIQkAabapk0Ocd4kePAYsLGxsRex84WTbZ1VEqq2DZIi18G8EjY2NvZl2b1W7iT85ClKNf0o1IuwsbGx17HzmZZqaak3ANRr6+YXNjY29iZ2Lw3IX/qr5aRb62o2g7GxsbFXsKuLJQFmHpB6LYHCY8DGxsZexK6+4ucthMmIT17Y6pWusLGxsXez5/XzXhCa4Js7x8bGxl7NzreVJxX5r+VhNW9aPFgFGxsbex07H6nMh3Lytmu1TdtrJ2BjY2PvY/eGXXql/+RQ8lbxqPiFjY2NvYg9H4tJDmWylTzlKKci2NjY2IvYZ736T0JUXlSaHCU2Njb2bva5ozzV9nB+6HnsPdgJNjY2NnYQ5OYlqkk7+eCYsLGxsb+YXR2j6QWe/Fh7QREbGxt7H3syUlNYrJgwVENdoTiFjY2NvYg9KdBU04xeo3eSCOUhFhsbG/uC7B9OGV3JRdf18QAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2020/05/09/Flink-DataSet-API编程指南/">Flink DataSet API编程指南</a><a class="next" href="/2020/04/30/Flink-DataStream-API-中的多面手——Process-Function详解/">Flink DataStream API 中的多面手——Process Function详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Start"><span class="toc-number">1.</span> <span class="toc-text">Quick Start</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#是什么"><span class="toc-number">1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何用"><span class="toc-number">1.2.</span> <span class="toc-text">如何用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keyed-Windows"><span class="toc-number">1.2.1.</span> <span class="toc-text">Keyed Windows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-Keyed-Windows"><span class="toc-number">1.2.2.</span> <span class="toc-text">Non-Keyed Windows</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简写window操作"><span class="toc-number">1.3.</span> <span class="toc-text">简写window操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-Assigners"><span class="toc-number">2.</span> <span class="toc-text">Window Assigners</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用介绍"><span class="toc-number">2.2.</span> <span class="toc-text">使用介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tumbling-Windows"><span class="toc-number">2.2.1.</span> <span class="toc-text">Tumbling Windows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sliding-Windows"><span class="toc-number">2.2.2.</span> <span class="toc-text">Sliding Windows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Windows"><span class="toc-number">2.2.3.</span> <span class="toc-text">Session Windows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Global-Windows"><span class="toc-number">2.2.4.</span> <span class="toc-text">Global Windows</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-Functions"><span class="toc-number">3.</span> <span class="toc-text">Window Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类-1"><span class="toc-number">3.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用介绍-1"><span class="toc-number">3.2.</span> <span class="toc-text">使用介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReduceFunction"><span class="toc-number">3.2.1.</span> <span class="toc-text">ReduceFunction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AggregateFunction"><span class="toc-number">3.2.2.</span> <span class="toc-text">AggregateFunction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FoldFunction"><span class="toc-number">3.2.3.</span> <span class="toc-text">FoldFunction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessWindowFunction"><span class="toc-number">3.2.4.</span> <span class="toc-text">ProcessWindowFunction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增量聚合函数和ProcessWindowFunction整合"><span class="toc-number">3.2.5.</span> <span class="toc-text">增量聚合函数和ProcessWindowFunction整合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window-生命周期解读"><span class="toc-number">4.</span> <span class="toc-text">window 生命周期解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期图解"><span class="toc-number">4.1.</span> <span class="toc-text">生命周期图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配器-Window-Assigners"><span class="toc-number">4.2.</span> <span class="toc-text">分配器(Window Assigners)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发器-Triggers"><span class="toc-number">4.3.</span> <span class="toc-text">触发器(Triggers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清除器-Evictors"><span class="toc-number">4.4.</span> <span class="toc-text">清除器(Evictors)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>