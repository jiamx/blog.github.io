<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Flink的八种分区策略源码解读 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink的八种分区策略源码解读</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink的八种分区策略源码解读</h1><div class="post-meta">Mar 30, 2020<span> | </span><span class="category"><a href="/categories/flink/">flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Flink包含8中分区策略，这8中分区策略(分区器)分别如下面所示，本文将从源码的角度一一解读每个分区器的实现方式。</p>
<a id="more"></a>

<ul>
<li><strong>GlobalPartitioner</strong></li>
<li><strong>ShufflePartitioner</strong></li>
<li><strong>RebalancePartitioner</strong></li>
<li><strong>RescalePartitioner</strong></li>
<li><strong>BroadcastPartitioner</strong></li>
<li><strong>ForwardPartitioner</strong></li>
<li><strong>KeyGroupStreamPartitioner</strong></li>
<li><strong>CustomPartitionerWrapper</strong></li>
</ul>
<h2 id="继承关系图"><a href="#继承关系图" class="headerlink" title="继承关系图"></a>继承关系图</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h4><p>**<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 实现</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface ChannelSelector&lt;T extends IOReadableWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 初始化channels数量，channel可以理解为下游Operator的某个实例(并行算子的某个subtask).</span><br><span class="line">	 */</span><br><span class="line">	void setup(int numberOfChannels);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 *根据当前的record以及Channel总数，</span><br><span class="line">	 *决定应将record发送到下游哪个Channel。</span><br><span class="line">	 *不同的分区策略会实现不同的该方法。</span><br><span class="line">	 */</span><br><span class="line">	int selectChannel(T record);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	*是否以广播的形式发送到下游所有的算子实例</span><br><span class="line">	 */</span><br><span class="line">	boolean isBroadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="名称-1"><a href="#名称-1" class="headerlink" title="名称"></a>名称</h4><p>**<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 实现</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public abstract class StreamPartitioner&lt;T&gt; implements</span><br><span class="line">		ChannelSelector&lt;SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt;&gt;, Serializable &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">	protected int numberOfChannels;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void setup(int numberOfChannels) &#123;</span><br><span class="line">		this.numberOfChannels = numberOfChannels;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isBroadcast() &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public abstract StreamPartitioner&lt;T&gt; copy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承关系图-1"><a href="#继承关系图-1" class="headerlink" title="继承关系图"></a>继承关系图</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5CFlink%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<h2 id="GlobalPartitioner"><a href="#GlobalPartitioner" class="headerlink" title="GlobalPartitioner"></a>GlobalPartitioner</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>该分区器会将所有的数据都发送到下游的某个算子实例(subtask id = 0)</p>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送所有的数据到下游算子的第一个task(ID = 0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalPartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//只返回0，即只发送给下游算子的第一个task</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"GLOBAL"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Cgloba.png" alt></p>
<h2 id="ShufflePartitioner"><a href="#ShufflePartitioner" class="headerlink" title="ShufflePartitioner"></a>ShufflePartitioner</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>随机选择一个下游算子实例进行发送</p>
<h3 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机的选择一个channel进行发送</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShufflePartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//产生[0,numberOfChannels)伪随机数，随机发送到下游的某个task</span></span><br><span class="line">		<span class="keyword">return</span> random.nextInt(numberOfChannels);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ShufflePartitioner&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"SHUFFLE"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Cshuffle.png" alt></p>
<h2 id="BroadcastPartitioner"><a href="#BroadcastPartitioner" class="headerlink" title="BroadcastPartitioner"></a>BroadcastPartitioner</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>发送到下游所有的算子实例</p>
<h3 id="源码解读-2"><a href="#源码解读-2" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送到所有的channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastPartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Broadcast模式是直接发送到下游的所有task，所以不需要通过下面的方法选择发送的通道</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Broadcast partitioner does not support select channels."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"BROADCAST"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Cbroadcast.png" alt></p>
<h2 id="RebalancePartitioner"><a href="#RebalancePartitioner" class="headerlink" title="RebalancePartitioner"></a>RebalancePartitioner</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>通过循环的方式依次发送到下游的task</p>
<h3 id="源码解读-3"><a href="#源码解读-3" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *通过循环的方式依次发送到下游的task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebalancePartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nextChannelToSendTo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> numberOfChannels)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setup(numberOfChannels);</span><br><span class="line">		<span class="comment">//初始化channel的id，返回[0,numberOfChannels)的伪随机数</span></span><br><span class="line">		nextChannelToSendTo = ThreadLocalRandom.current().nextInt(numberOfChannels);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//循环依次发送到下游的task，比如：nextChannelToSendTo初始值为0，numberOfChannels(下游算子的实例个数，并行度)值为2</span></span><br><span class="line">		<span class="comment">//则第一次发送到ID = 1的task，第二次发送到ID = 0的task，第三次发送到ID = 1的task上...依次类推</span></span><br><span class="line">		nextChannelToSendTo = (nextChannelToSendTo + <span class="number">1</span>) % numberOfChannels;</span><br><span class="line">		<span class="keyword">return</span> nextChannelToSendTo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"REBALANCE"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Crebalance.png" alt></p>
<h2 id="RescalePartitioner"><a href="#RescalePartitioner" class="headerlink" title="RescalePartitioner"></a>RescalePartitioner</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>基于上下游Operator的并行度，将记录以循环的方式输出到下游Operator的每个实例。<br>  举例: 上游并行度是2，下游是4，则上游一个并行度以循环的方式将记录输出到下游的两个并行度上;上游另一个并行度以循环的方式将记录输出到下游另两个并行度上。<br> 若上游并行度是4，下游并行度是2，则上游两个并行度将记录输出到下游一个并行度上；上游另两个并行度将记录输出到下游另一个并行度上。</p>
<h3 id="源码解读-4"><a href="#源码解读-4" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RescalePartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nextChannelToSendTo = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (++nextChannelToSendTo &gt;= numberOfChannels) &#123;</span><br><span class="line">			nextChannelToSendTo = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nextChannelToSendTo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"RESCALE"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解-4"><a href="#图解-4" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Crescale.png" alt></p>
<h4 id="尖叫提示"><a href="#尖叫提示" class="headerlink" title="尖叫提示"></a>尖叫提示</h4><p>Flink 中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图。</p>
<p>**<figure class="highlight plain"><figcaption><span>Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**```JobGraph```**：StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。</span><br><span class="line"></span><br><span class="line">**```ExecutionGraph```**：JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。</span><br><span class="line"></span><br><span class="line">物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。</span><br><span class="line"></span><br><span class="line"> 而StreamingJobGraphGenerator就是StreamGraph转换为JobGraph。在这个类中，把ForwardPartitioner和RescalePartitioner列为POINTWISE分配模式，其他的为ALL_TO_ALL分配模式。代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">if (partitioner instanceof ForwardPartitioner || partitioner instanceof RescalePartitioner) &#123;</span><br><span class="line">			jobEdge = downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">				headVertex,</span><br><span class="line"></span><br><span class="line">			   // 上游算子(生产端)的实例(subtask)连接下游算子(消费端)的一个或者多个实例(subtask)</span><br><span class="line">				DistributionPattern.POINTWISE,</span><br><span class="line">				resultPartitionType);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			jobEdge = downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">				headVertex,</span><br><span class="line">				// 上游算子(生产端)的实例(subtask)连接下游算子(消费端)的所有实例(subtask)</span><br><span class="line">				DistributionPattern.ALL_TO_ALL,</span><br><span class="line">				resultPartitionType);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ForwardPartitioner"><a href="#ForwardPartitioner" class="headerlink" title="ForwardPartitioner"></a>ForwardPartitioner</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>发送到下游对应的第一个task，保证上下游算子并行度一致，即上有算子与下游算子是1:1的关系</p>
<h3 id="源码解读-5"><a href="#源码解读-5" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送到下游对应的第一个task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardPartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"FORWARD"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图解-5"><a href="#图解-5" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Cforward.png" alt></p>
<h4 id="尖叫提示-1"><a href="#尖叫提示-1" class="headerlink" title="尖叫提示"></a>尖叫提示</h4><p>在上下游的算子没有指定分区器的情况下，如果上下游的算子并行度一致，则使用ForwardPartitioner，否则使用RebalancePartitioner，对于ForwardPartitioner，必须保证上下游算子并行度一致，否则会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上下游的算子没有指定分区器的情况下，如果上下游的算子并行度一致，则使用ForwardPartitioner，否则使用RebalancePartitioner</span></span><br><span class="line">			<span class="keyword">if</span> (partitioner == <span class="keyword">null</span> &amp;&amp; upstreamNode.getParallelism() == downstreamNode.getParallelism()) &#123;</span><br><span class="line">				partitioner = <span class="keyword">new</span> ForwardPartitioner&lt;Object&gt;();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">				partitioner = <span class="keyword">new</span> RebalancePartitioner&lt;Object&gt;();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (partitioner <span class="keyword">instanceof</span> ForwardPartitioner) &#123;</span><br><span class="line">				<span class="comment">//如果上下游的并行度不一致，会抛出异常</span></span><br><span class="line">				<span class="keyword">if</span> (upstreamNode.getParallelism() != downstreamNode.getParallelism()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Forward partitioning does not allow "</span> +</span><br><span class="line">						<span class="string">"change of parallelism. Upstream operation: "</span> + upstreamNode + <span class="string">" parallelism: "</span> + upstreamNode.getParallelism() +</span><br><span class="line">						<span class="string">", downstream operation: "</span> + downstreamNode + <span class="string">" parallelism: "</span> + downstreamNode.getParallelism() +</span><br><span class="line">						<span class="string">" You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global."</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KeyGroupStreamPartitioner"><a href="#KeyGroupStreamPartitioner" class="headerlink" title="KeyGroupStreamPartitioner"></a>KeyGroupStreamPartitioner</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>根据key的分组索引选择发送到相对应的下游subtask</p>
<h3 id="源码解读-6"><a href="#源码解读-6" class="headerlink" title="源码解读"></a>源码解读</h3><ul>
<li>org.apache.flink.streaming.runtime.partitioner.KeyGroupStreamPartitioner</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key的分组索引选择发送到相对应的下游subtask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyGroupStreamPartitioner</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ConfigurableStreamPartitioner</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		K key;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			key = keySelector.getKey(record.getInstance().getValue());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not extract key from "</span> + record.getInstance().getValue(), e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用KeyGroupRangeAssignment类的assignKeyToParallelOperator方法,代码如下所示</span></span><br><span class="line">		<span class="keyword">return</span> KeyGroupRangeAssignment.assignKeyToParallelOperator(key, maxParallelism, numberOfChannels);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>org.apache.flink.runtime.state.KeyGroupRangeAssignment</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyGroupRangeAssignment</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据key分配一个并行算子实例的索引，该索引即为该key要发送的下游算子实例的路由信息，</span></span><br><span class="line"><span class="comment">	 * 即该key发送到哪一个task</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignKeyToParallelOperator</span><span class="params">(Object key, <span class="keyword">int</span> maxParallelism, <span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">		Preconditions.checkNotNull(key, <span class="string">"Assigned key must not be null!"</span>);</span><br><span class="line">		<span class="keyword">return</span> computeOperatorIndexForKeyGroup(maxParallelism, parallelism, assignToKeyGroup(key, maxParallelism));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *根据key分配一个分组id(keyGroupId)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignToKeyGroup</span><span class="params">(Object key, <span class="keyword">int</span> maxParallelism)</span> </span>&#123;</span><br><span class="line">		Preconditions.checkNotNull(key, <span class="string">"Assigned key must not be null!"</span>);</span><br><span class="line">		<span class="comment">//获取key的hashcode</span></span><br><span class="line">		<span class="keyword">return</span> computeKeyGroupForKeyHash(key.hashCode(), maxParallelism);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据key分配一个分组id(keyGroupId),</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeKeyGroupForKeyHash</span><span class="params">(<span class="keyword">int</span> keyHash, <span class="keyword">int</span> maxParallelism)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//与maxParallelism取余，获取keyGroupId</span></span><br><span class="line">		<span class="keyword">return</span> MathUtils.murmurHash(keyHash) % maxParallelism;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算分区index，即该key group应该发送到下游的哪一个算子实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeOperatorIndexForKeyGroup</span><span class="params">(<span class="keyword">int</span> maxParallelism, <span class="keyword">int</span> parallelism, <span class="keyword">int</span> keyGroupId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> keyGroupId * parallelism / maxParallelism;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="图解-6"><a href="#图解-6" class="headerlink" title="图解"></a>图解</h3><p><img src="//jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/Flink%E7%9A%84%E5%85%AB%E7%A7%8D%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5Ckey.png" alt></p>
<h2 id="CustomPartitionerWrapper"><a href="#CustomPartitionerWrapper" class="headerlink" title="CustomPartitionerWrapper"></a>CustomPartitionerWrapper</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>通过<code>Partitioner</code>实例的<code>partition</code>方法(自定义的)将记录输出到下游。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitionerWrapper</span>&lt;<span class="title">K</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">StreamPartitioner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	Partitioner&lt;K&gt; partitioner;</span><br><span class="line">	KeySelector&lt;T, K&gt; keySelector;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomPartitionerWrapper</span><span class="params">(Partitioner&lt;K&gt; partitioner, KeySelector&lt;T, K&gt; keySelector)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.partitioner = partitioner;</span><br><span class="line">		<span class="keyword">this</span>.keySelector = keySelector;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectChannel</span><span class="params">(SerializationDelegate&lt;StreamRecord&lt;T&gt;&gt; record)</span> </span>&#123;</span><br><span class="line">		K key;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			key = keySelector.getKey(record.getInstance().getValue());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not extract key from "</span> + record.getInstance(), e);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//实现Partitioner接口，重写partition方法</span></span><br><span class="line">		<span class="keyword">return</span> partitioner.partition(key, numberOfChannels);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> StreamPartitioner&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"CUSTOM"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// key: 根据key的值来分区</span></span><br><span class="line">      <span class="comment">// numPartitions: 下游算子并行度</span></span><br><span class="line">	  <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> key.length() % numPartitions;<span class="comment">//在此处定义分区策略</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2020/04/02/你真的了解Flink-Kafka-connector吗？/" target="_blank">你真的了解Flink Kafka source吗？</a></li><li><a href="https://jiamaoxiang.top/2020/03/31/Flink1-10集成Hive快速入门/" target="_blank">Flink1.10集成Hive快速入门</a></li><li><a href="https://jiamaoxiang.top/2020/03/24/基于Canal与Flink实现数据实时增量同步-二/" target="_blank">基于Canal与Flink实现数据实时增量同步(二)</a></li><li><a href="https://jiamaoxiang.top/2020/03/22/分布式数据集成框架gobblin快速入门/" target="_blank">分布式数据集成框架gobblin快速入门</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/03/30/Flink的八种分区策略源码解读/">https://jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2020/03/30/Flink的八种分区策略源码解读/" data-id="ck8vfc6ay0022607qurb67o9d" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuUlEQVR42u3aQW7DQAgF0Nz/0u02Umv3A0PjxfMqSiJ73kQaCPB6xdfX23X1/s/r/jvvn169vvr08IWHh4c3WHqyxKuH3ZNywGTLftkCPDw8vDXe1YmaLOs+hOSk5Ln5mvHw8PCeyasmvvl98i3Dw8PDez4vSZoTZIL5QGDAw8PDi3nV4z4v7Pa+nwSGw7UWPDw8vJiXd5Ge83qlv4eHh4c37qrPm1j5c5NEubxaPDw8vAVefuD2Et/qQEAP/8ca8PDw8I7ykhJDrySRDGZVx7mqwQkPDw9vg5cc6NVhqd4gQrUQXCjg4uHh4S3wkvS3l/JuDFRVQxEeHh7eWV71YO21/+dDA+VfCQ8PD2+N1wsPSbKbJ+vV9liSZOPh4eHt8fICQW9x/zk7djkZgYeHh3eUlyevvfZ/tUycFH+rTTg8PDy8s7wkLT7VsjpbLC509vDw8PDWeJPkeIKZBKQ/ghweHh7eh3jVJfaKsPdblt+hHBjw8PDwWrxJkyk5uE9tYnlgCw8PD2+BN2k+9TYi35T7AJYk4nh4eHgbvDyFTUoP8+GDXhCKJiPw8PDwDvHy9nwSJKoN/l6JNl8DHh4e3gYvSWGTdDYPJ/kYVm8G4PJ3w8PDwzvEm98oH9KaBIBJmRgPDw9vg1f+e19s7eeB5+x4Fh4eHt42r5qe5ovIQ0g1XS6n0Xh4eHjLvLytlRz0kydOBhrw8PDw9njVYkEeEiYBo9eKw8PDw9vjfRWvXjqew3JwtB14eHh4C7zegZsvq/dOnqzPU3A8PDy8Hi8JBtU2VT46MLlPYbIMDw8Pb4GXH8rVYayzgwLVDhceHh7eE3i9ZeV3SEoMhXEHPDw8vAfwkgdXS8C9gbCosoKHh4e3xquWBnphoFcyzhtdl4EBDw8P7yiv94e/OtuVLDQpeSQDXnh4eHhrvG9yIYi927mJzgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2020/03/31/Flink1-10集成Hive快速入门/">Flink1.10集成Hive快速入门</a><a class="next" href="/2020/03/24/基于Canal与Flink实现数据实时增量同步-二/">基于Canal与Flink实现数据实时增量同步(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#继承关系图"><span class="toc-number">1.</span> <span class="toc-text">继承关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.1.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名称"><span class="toc-number">1.1.1.</span> <span class="toc-text">名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">1.2.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名称-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承关系图-1"><span class="toc-number">1.3.</span> <span class="toc-text">继承关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GlobalPartitioner"><span class="toc-number">2.</span> <span class="toc-text">GlobalPartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读"><span class="toc-number">2.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解"><span class="toc-number">2.3.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShufflePartitioner"><span class="toc-number">3.</span> <span class="toc-text">ShufflePartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-1"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-1"><span class="toc-number">3.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-1"><span class="toc-number">3.3.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadcastPartitioner"><span class="toc-number">4.</span> <span class="toc-text">BroadcastPartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-2"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-2"><span class="toc-number">4.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-2"><span class="toc-number">4.3.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RebalancePartitioner"><span class="toc-number">5.</span> <span class="toc-text">RebalancePartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-3"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-3"><span class="toc-number">5.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-3"><span class="toc-number">5.3.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RescalePartitioner"><span class="toc-number">6.</span> <span class="toc-text">RescalePartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-4"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-4"><span class="toc-number">6.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-4"><span class="toc-number">6.3.</span> <span class="toc-text">图解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#尖叫提示"><span class="toc-number">6.3.1.</span> <span class="toc-text">尖叫提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForwardPartitioner"><span class="toc-number">7.</span> <span class="toc-text">ForwardPartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-5"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-5"><span class="toc-number">7.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-5"><span class="toc-number">7.3.</span> <span class="toc-text">图解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#尖叫提示-1"><span class="toc-number">7.3.1.</span> <span class="toc-text">尖叫提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeyGroupStreamPartitioner"><span class="toc-number">8.</span> <span class="toc-text">KeyGroupStreamPartitioner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-6"><span class="toc-number">8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解读-6"><span class="toc-number">8.2.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解-6"><span class="toc-number">8.3.</span> <span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CustomPartitionerWrapper"><span class="toc-number">9.</span> <span class="toc-text">CustomPartitionerWrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-7"><span class="toc-number">9.1.</span> <span class="toc-text">简介</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2020 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>