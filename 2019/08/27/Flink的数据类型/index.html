<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录朴实无华且枯燥的生活"><title>Flink的数据类型 | Jmx's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '912b6cfc43243cd27aeb428f7dbf7823';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink的数据类型</h1><a id="logo" href="/.">Jmx's Blog</a><p class="description">Keep it Simple and Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-pied-piper-alt"> 关于</i></a><a href="/tags"><i class="fa fa-tags"> 标签</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink的数据类型</h1><div class="post-meta">Aug 27, 2019<span> | </span><span class="category"><a href="/categories/Flink/">Flink</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 907</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 3</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Flink使用type information来代表数据类型，Flink还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获取类型信息(type information)，从而获得序列化程序和反序列化程序。但是，在某些情况下，例如lambda函数或泛型类型，需要显式地提供类型信息((type information)),从而提高其性能。本文主要讨论包括：(1)Flink支持的数据类型,(2)如何为数据类型创建type information，（3）如果无法自动推断函数的返回类型，如何使用提示(hints)来帮助Flink的类型系统识别类型信息。</p>
<a id="more"></a>
<h1 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h1><p>Flink支持Java和Scala中所有常见的数据类型，使用比较广泛的类型主要包括以下五种：</p>
<ul>
<li>原始类型  </li>
<li>Java和Scala的tuple类型  </li>
<li>Scala样例类  </li>
<li>POJO类型  </li>
<li>一些特殊的类型  </li>
</ul>
<p><strong>NOTE：</strong>不能被处理的类型将会被视为普通的数据类型，通过Kyro序列化框架进行序列化。</p>
<h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>Flink支持所有Java和Scala的原始类型，比如Int(Java中的Integer)，String、Double等。下面的例子是处理一个Long类型的数据流，处理每个元素+1  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">val numbers: DataStream[Long] = env.fromElements(<span class="number">1L</span>, <span class="number">2L</span>,<span class="number">3L</span>, <span class="number">4L</span>)  </span><br><span class="line">numbers.map( n =&gt; n + 1)</span><br></pre></td></tr></table></figure>

<h2 id="Java和Scala的tuple类型"><a href="#Java和Scala的tuple类型" class="headerlink" title="Java和Scala的tuple类型"></a>Java和Scala的tuple类型</h2><p>基于Scala的DataStream API使用的Scala的tuple。下面的例子是过滤一个具有两个字段的tuple类型的数据流.  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// DataStream of Tuple2[String, Integer] <span class="keyword">for</span> Person(name,age)  </span><br><span class="line">val persons: DataStream[(String, Integer)] = env.fromElements((<span class="string">"Adam"</span>, <span class="number">17</span>),(<span class="string">"Sarah"</span>, <span class="number">23</span>))  </span><br><span class="line">// filter <span class="keyword">for</span> persons of age &gt; <span class="number">18</span>  </span><br><span class="line">persons.filter(p =&gt; p._2 &gt; 18)</span><br></pre></td></tr></table></figure>

<p>Flink提供了有效的Java tuple实现，Flink的Java tuple最多包括25个字段，分别为tuple1，tuple2，直到tuple25，tuple类型是强类型的。使用Java DataStream API重写上面的例子:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// DataStream of Tuple2&lt;String, Integer&gt; <span class="keyword">for</span> Person(name,age)  </span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons =env.fromElements(Tuple2.of(<span class="string">"Adam"</span>, <span class="number">17</span>),Tuple2.of(<span class="string">"Sarah"</span>,<span class="number">23</span>));  </span><br><span class="line">// filter <span class="keyword">for</span> persons of age &gt; <span class="number">18</span>  </span><br><span class="line">persons.filter(p -&gt; p.f1 &gt; 18);</span><br></pre></td></tr></table></figure>

<p>Tuple字段可以通过使用f0，f1，f2的形式访问，也可以通过getField(int pos)方法访问，参数的索引起始值为0，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of(<span class="string">"Alex"</span>,<span class="string">"42"</span>);  </span><br><span class="line">Integer age = personTuple.getField(<span class="number">1</span>); // age = <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>与Scala相比，Flink的Java tuple是可变的，所以tuple的元素值是可以被重新复制的。Function可以重用Java tuple,从而减小垃圾回收的压力。下面的例子展示了如何更新一个tuple字段值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">personTuple.f1 = <span class="number">42</span>; // set the <span class="number">2</span>nd field to <span class="number">42</span>     </span><br><span class="line">personTuple.setField(<span class="number">43</span>, <span class="number">1</span>); // set the <span class="number">2</span>nd field to <span class="number">43</span></span><br></pre></td></tr></table></figure>

<h2 id="Scala的样例类"><a href="#Scala的样例类" class="headerlink" title="Scala的样例类"></a>Scala的样例类</h2><p>Flink支持Scala的样例类，可以通过字段名称来访问样例类的字段，下面的例子定义了一个<code>Person</code>样例类，该样例类有两个字段：<code>name</code>和<code>age</code>,按<code>age</code>过滤DataStream，如下所示</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">case <span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(name: String, age: Int)</span>  </span></span><br><span class="line"><span class="class">	<span class="title">val</span> <span class="title">persons</span>:</span> DataStream[Person] = env.fromElements(Person(<span class="string">"Adam"</span>, <span class="number">17</span>),Person(<span class="string">"Sarah"</span>, <span class="number">23</span>))  </span><br><span class="line">	// filter <span class="keyword">for</span> persons <span class="keyword">with</span> age &gt; <span class="number">18</span>  </span><br><span class="line">	persons.filter(p =&gt; p.age &gt; 18)</span><br></pre></td></tr></table></figure>


<h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><p>Flink接受的POJO类型需满足以下条件：</p>
<ul>
<li>public 类  </li>
<li>无参的共有构造方法  </li>
<li>所有字段都是public的，可以通过getter和setter方法访问  </li>
<li>所有字段类型必须是Flink能够支持的<br>下面的例子定义一个<code>Person</code>POJO</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public class Person &#123;  </span><br><span class="line">// both fields are public  </span><br><span class="line">public String name;  </span><br><span class="line">public int age;  </span><br><span class="line">// default constructor <span class="keyword">is</span> present  </span><br><span class="line">public Person() &#123;&#125;  </span><br><span class="line">public Person(String name, int age) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.age = age;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">DataStream&lt;Person&gt; persons = env.fromElements(   </span><br><span class="line">new Person(<span class="string">"Alex"</span>, <span class="number">42</span>),  </span><br><span class="line">new Person(<span class="string">"Wendy"</span>, <span class="number">23</span>));</span><br></pre></td></tr></table></figure>

<h2 id="一些特殊的类型"><a href="#一些特殊的类型" class="headerlink" title="一些特殊的类型"></a>一些特殊的类型</h2><p>Flink支持一些有特殊作用的数据类型，比如Array，Java中的ArrayList、HashMap和Enum等，也支持Hadoop的Writable类型。  </p>
<h1 id="为数据类型创建类型信息-type-information"><a href="#为数据类型创建类型信息-type-information" class="headerlink" title="为数据类型创建类型信息(type information)"></a>为数据类型创建类型信息(type information)</h1><h1 id="显示地指定类型信息-type-information"><a href="#显示地指定类型信息-type-information" class="headerlink" title="显示地指定类型信息(type information)"></a>显示地指定类型信息(type information)</h1></div><div class="recommended_posts"><h3>相关推荐 ☟</h3><li><a href="https://jiamaoxiang.top/2019/08/29/Impala使用的端口/" target="_blank">Impala使用的端口</a></li><li><a href="https://jiamaoxiang.top/2019/08/28/Azkaban安装部署/" target="_blank">Azkaban安装部署</a></li><li><a href="https://jiamaoxiang.top/2019/08/26/基于SparkStreaming的日志分析项目/" target="_blank">基于SparkStreaming的日志分析项目</a></li><li><a href="https://jiamaoxiang.top/2019/08/23/Flink的状态后端-State-Backends/" target="_blank">Flink的状态后端(State Backends)</a></li></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Jia MaoXiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/08/27/Flink的数据类型/">https://jiamaoxiang.top/2019/08/27/Flink的数据类型/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为博主原创文章，遵循CC BY-SA 4.0版权协议，转载请附上原文出处链接和本声明</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://jiamaoxiang.top/2019/08/27/Flink的数据类型/" data-id="cjzxq3gia0002p47qc2jvhmk0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNklEQVR42u3a0U7DMAwFUP7/p4fEExJ0u9fpEE1PnqZtZDlFsuzYHx/xenyt76+TdbTPz0+Tvz1hYWBgXJaRHGWF8fzozxnFY8LAwLgBIwmyLeNoh+To+dkwMDAw2qCcvJPkdRgYGBgrAfc5Mj/c7HcxMDDuzJgF03yf/ALu7bU4BgbGBRmzxsDfvH57fwMDA+PfMx7LaxZ8V0L2L7thYGBszUhKyqSAXEkBkwI4CsQYGBg3YLSFaH6g9dGK6IFiYGDcgJGEv5V2Y75z2zzAwMC4J2P28+vXZ0tpIgYGxqaM9ujJ4EUbfGfXcEv1MQYGxqUYs+ZlW8omR2ybmjUJAwPjsox3BNz1NLEOvhgYGFsz2vZknla2pLZJULQzMTAwtmDkhWUeLmcJX3slF7UwMTAwLs7Iw9xKc7EN1jUbAwNja8ZsGGuloJ0dOjoPBgbG1ow8i2zL0Vn4zq/86hCMgYFxQUZ7vZWMiCXvz5oBh/8HDAyMrRkrI2LnDm+1RfJpk24YGBgXYczC6Mr3Z43POtRiYGBsx0iSxfaOaxagZ4MdGBgYezPa1mPeTljKVUdtCQwMjP0Yj3KddU02SwQP98fAwNiasRKh23CZD1LMvomBgbE3Ix+JmJWs+dBGO2zxItPEwMDYjjG7aW9DZF7iJkXv4a0hBgYGRlB2Jkc8bRQMAwMDo2witolgDnuxAwYGxg0YSRE7u7drBzhm7UwMDIy9GW1joG1D5o+sHc5Y6m9gYGBcg/EJJbbwLs1cYxsAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a class="pre" href="/2019/08/28/Azkaban安装部署/">Azkaban安装部署</a><a class="next" href="/2019/08/26/基于SparkStreaming的日志分析项目/">基于SparkStreaming的日志分析项目</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-list-ul"> 目录</i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#支持的数据类型"><span class="toc-number">1.</span> <span class="toc-text">支持的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始类型"><span class="toc-number">1.1.</span> <span class="toc-text">原始类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java和Scala的tuple类型"><span class="toc-number">1.2.</span> <span class="toc-text">Java和Scala的tuple类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scala的样例类"><span class="toc-number">1.3.</span> <span class="toc-text">Scala的样例类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POJO"><span class="toc-number">1.4.</span> <span class="toc-text">POJO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些特殊的类型"><span class="toc-number">1.5.</span> <span class="toc-text">一些特殊的类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为数据类型创建类型信息-type-information"><span class="toc-number">2.</span> <span class="toc-text">为数据类型创建类型信息(type information)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#显示地指定类型信息-type-information"><span class="toc-number">3.</span> <span class="toc-text">显示地指定类型信息(type information)</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 - 2019 <a href="/." rel="nofollow">Jmx's Blog.</a>All rights reserved.<br>Thoughts on technology, life and everything else.</div></div></div><script type="text/javascript" src="/js/toc.js?v=0.0.0"></script><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.5" zindex="0.7" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>